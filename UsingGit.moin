Several X.Org projects have been moved to the git revision control system.  While there exist tutorials out there for using git, one of git's features is that it allows people to use many different workflows, so many of those tutorials won't apply to git as it's used in X.Org projects.  We might call what we usually do "shared central repository" mode.

Things which are within the scope of this document:
 * Checking out code
 * Committing code
 * Resolving conflicts
 * Working on branches

Things which are not within the scope of this document:
 * Using the index for selective committing
 * Maintaining public personal repositories

First note about git: there are many commands.  Each command exists as an arugment to the git command ("git clone") and also as a hyphenated version to aid in tab-completion ("git-clone").

The next thing to understand is that when you check out code from a remote git repository, you end up with a full-fledged git repository yourself.  When you diff, commit, etc. code, you are doing it against your local repository.  Clone, pull, and push are used to move changes between repositories.  Your local repository is stored in .git at the top of the tree.

== Checking out repositories ==

To initially check out a repository, you use git clone.  An example for libX11:

{{{ git clone git://anongit.freedesktop.org/git/xorg/lib/libX11 }}}

The git:// protocol is fast, but is read-only.  Pushing requires ssh, so if you're a developer, you would use:

{{{ git clone git+ssh://git.freedesktop.org/git/xorg/lib/libX11 }}}

If you become a developer at a later time, you can edit {{{.git/remotes/origin}}} and replace the contents of the {{{URL: }}} line.

Currently, there are four git repositories available:

git://anongit.freedesktop.org/git/xorg/lib/libX11
git://anongit.freedesktop.org/git/xorg/proto/compositeproto
git://anongit.freedesktop.org/git/xorg/proto/damageproto
git://anongit.freedesktop.org/git/xorg/proto/fixesproto

== Viewing diffs ==
Now, you have a copy of the master branch of the tree.  Go ahead and build it and whatever else.  If you make some changes, you can see what files you would commit with
{{{ git status -a }}}
or get a diff of the local tree against the repository with
{{{ git status -a -v}}}

The {{{-a}}} flag means all local updates.  The git system actually has this concept of an "index", managed using git-update-index, which lets you selectively commit changes.  However, because this adds to confusion, I will leave learning about the index up to you to do later.

== Getting the latest upstream code ==
The command to update your local repository is:

{{{git pull}}}

It will pull down the latest repository information from the {{{origin}}} remote file (which points at where you initially cloned the repository from), then merge.  If the new changes don't conflict with anything locally, the merge will "fast-forward" your branch reference to the new head.  If new changes do conflict, it will try to do an automatic merge using a couple of different schemes, and then automatically commits the merge if it's satisfied.  If you notice that your pull resulted in a merge (in the output of pull), you might want to use {{{gitk}}} to see if the merge did what you expected it to.  If it isn't satisfied, then you have to resolve the conflict manually.

== Dealing with conflicts ==
If you get a serious conflict that can't be merged automatically, git will leave familiar conflict markers in the files, and {{{ git status }}} should say that you've got unmerged files.  Go edit them and fix your conflicts, and test.  After you do so, {{{git status}}} will still be noisy about unmerged files (since you haven't updated the index to say you've merged them), but you can still do

{{{git commit -a}}}

and commit your merge.  It hands you a default log message for the merge, and it will retain the information on the parents of the commit you did, so that branch history is maintained.

== Reverting commits ==
It may happen that you commit something you really didn't want to go into the repository.  This is not referring to broken changes, but things like mis-merges or getting branches confused.  If you haven't pushed the code upstream, then it's really easy to make it look like the commit didn't happen.  To reset to the immediate previous revision, you would run:

{{{git reset --hard HEAD^}}}

== Committing code ==
If you're satisfied with your diff, you could commit it with:
{{{git commit -a}}}

After you enter your log message, it will quickly terminate.  You've now committed your diff to your local repository.  You could run:

{{{gitk}}}

to see your diff in the history now.  Note that the {{{gitk}}} output actually shows two branches: master and origin.  The "master" branch is the head of development in the local tree.  The "origin" branch is the last version from upstream.

== Pushing your code upstream ==

Now that you've resolved the conflicts (if any) with others upstream, you're ready to push your changes.  To do this, type

{{{git push origin}}}

This tells git to push every branch in a "Push:" line in the "origin" remote upstream (more on the Push: lines later).  Unlike git pull, git push does require you to specify the remote and doesn't have a default.

== Working on branches ==
Now you've learned how to check out HEAD code, diff, update, commit, and push code back upstream.  The next thing to talk about is branching.

You can see what branch you're on using "git branch" -- it should show "master" initially.  To switch branches in your current repository, do:

{{{git checkout <branch>}}}

If you've got local changes, there are flags to either throw out your local changes, or try to merge them across to the new branch.  By default it will just refuse to change.

If you want to make a new branch, you can do:

{{{git checkout -b <new-branch>}}}

Now you've got a new branch.  However, git checkout doesn't set up the branch: branch-origin mapping that we want.  There's a rule in using git, which is: '''Never commit to the right side of a Pull line'''.  This is referring to the contents of .git/remotes/<remotename>.  The .git/remotes/origin (what you're using currently) file should currently have:
{{{
URL: git://anongit.freedesktop.org/git/whatever
Pull: master:origin
}}}

This means that the current remote master is mapped to the local origin.  When working on a branch where you'll be committing code, add a few more lines:
{{{
Push: master:master
Pull: new-branch:new-branch-origin
Push: new-branch:new-branch
}}}
The first says "map the remote new-branch to new-branch-origin in the local repository".  The second says "when pushing code, push from new-branch locally into new-branch remotely".  If you haven't set any Push: lines, then git implies a "master:master" mapping for pushes.  Once we add our new-branch push line, we also have to addm aster:master if you intend to ever commit to master.

Now, you're set up for committing and pushing the branch.  There's one more trick to know about.  When you do "git pull", it is now pulling the remote branches into what they're mapped to locally.  So, the latest new-branch upstream code is in new-branch-origin.  To merge it to your local new-branch code, do:

{{{git pull . new-branch-origin}}}

This means "merge the new-branch-origin code into the current working directory".  Like the other git pull command we mentioned, it will by default commit the merge, unless it runs into conflicts which aren't automatically resolvable.

And, to push, you do it just like when you were working on master.

{{{git push origin}}}

I think that should be it for this guide.  Please feel free to edit for grammar, and send questions to me (anholt on #freedesktop) --EricAnholt
 
Things I find unintuitive in git that I think ought to be fixed:
 * git diff should do what git status -a -v does
 * the index should be second-class, i.e. no -a flags to avoid the index.
 * branch:branch-origin (or something) should be the default pull.
 * branch:branch should be the default push for all branches, but only push the current branch unless a flag is added
 * an update command should be created that:
  * fetches the current branch's upstream to its -origin locally (or all branches, perhaps)
  * merges the current branch origin to the branch locally
  * commits if it was a fast-forward, and leaves uncommitted diffs otherwise.


