Several X.Org projects have been moved to the git revision control system.  While there exist tutorials out there for using git, one of git's features is that it allows people to use many different workflows, so many of those tutorials won't apply to git as it's used in X.Org projects.  We might call what we usually do "shared central repository" mode.

Things which are within the scope of this document:
 * Checking out code
 * Committing code
 * Resolving conflicts
 * Working on branches

Things which are not within the scope of this document:
 * Using the index for selective committing
 * Maintaining public personal repositories

First note about git: there are many commands.  Each command exists as an arugment to the git command ("git clone") and also as a hyphenated version to aid in tab-completion ("git-clone").

The next thing to understand is that when you check out code from a remote git repository, you end up with a full-fledged git repository yourself.  When you diff, commit, etc. code, you are doing it against your local repository.  Clone, pull, and push are used to move changes between repositories.  Your local repository is stored in .git at the top of the tree.

To initially check out a repository, you use git clone.  An example for libX11:

{{{ git clone git://anongit.freedesktop.org/git/xorg/lib/libX11 }}}

The git:// protocol is fast, but is read-only.  Pushing requires ssh, so if you're a developer, you would use:

{{{ git clone git+ssh://git.freedesktop.org/git/xorg/lib/libX11 }}}

If you become a developer at a later time, you can edit {{{.git/remotes/origin}}} and replace the contents of the {{{URL: }}} line.

Now, you have a copy of the master branch of the tree.  Go ahead and build it and whatever else.  If you make some changes, you can see what you would commit with
{{{ git status -a }}}
or get a diff of the local tree against the repository with
{{{ git status -a -v}}}

The {{{-a}}} flag means all local updates.  The git system actually has this concept of an index, which is managed using git-update-index, which lets you selectively commit changes.  However, because this adds to confusion, I will leave learning about the index up to you to do later.

If you're satisfied with your diff, you could commit it with:
{{{git commit -a}}}

After you enter your log message, it will quickly terminate.  You've now committed your diff to your local repository.  You could run:

{{{gitk}}}

to see your diff in the history now.  Note that the {{{gitk}}} output actually shows two branches: master and origin.  The "master" branch is the head of development in the local tree.  The "origin" branch is the last version from upstream.  Let's suppose we want to push our change upstream.  Since it may have been a couple of days, we would do:

{{{git pull}}}

which pulls down the latest repository information from the {{{origin}}} remote file (which points at where you initially cloned the repository from).  If someone else made a change, that change may or may not conflict with what you had done.  If git can merge it, it will automatically commit the merge to your local repository.  Sometimes automatic merging is not the right thing -- you can avoid it with a flag to git-pull, but you can also revert it using

{{{git reset --hard HEAD^}}}

This means "reset everything (repository, index, checkout) to the way it was in the previous revision of the HEAD branch".  Additional carats mean previous revisions.  HEAD is a simple pointer at whatever branch you're currently on.  Since your repository is local, it will be as if this automatic merge never happened.  Then you could go back and do a git-pull with --no-commit and make your merge happen how you wanted.  Usually it's just fine, though.

But let's suppose you got a serious conflict, and git decides it can't deal with it.  If so, then
{{{ git status }}} should say that you've got unmerged files.  Go edit them and fix your conflicts, and test.  After you do so, {{{git status}}} will still be noisy about unmerged files (since you haven't updated the index to say you've merged them), but you can still do

{{{git commit -a}}}

and commit your merge.  It hands you a default log message for the merge, and it will retain the information on the parents of the commit you did, so that branch history is maintained.

Now that you've resolved the conflicts (if any) with others upstream, you're ready to push your changes.  To do this, type

{{{git push origin}}}

This tells git to push the current branch (master) to the "origin" remote.  Unlike git pull, git push does require you to specify the remote and doesn't have a default.

Now you've learned how to check out HEAD code, diff, update, commit, and push code back upstream.  The next thing to talk about is branching.

You can see what branch you're on using "git branch" -- it should show "master" initially.  To switch branches in your current repository, do:

{{{git checkout <branch>}}}

If you've got local changes, there are flags to either throw out your local changes, or try to merge them across to the new branch.  By default it will just refuse to change.

If you want to make a new branch, you can do:

{{{git checkout -b <new-branch>}}}

Now you've got a new branch.  However, git checkout doesn't set up the branch: branch-origin mapping that we want.  There's a rule in using git, which is: '''Never commit to the right side of a Pull line'''.  This is referring to the contents of .git/remotes/<remotename>.  The .git/remotes/origin (what you're using currently) file should currently have:
{{{
URL: git://anongit.freedesktop.org/git/whatever
Pull: master:origin
}}}

This means that the current remote master is mapped to the local origin.  When working on a branch where you'll be committing code, add a few more lines:
{{{
Push: master:master
Pull: new-branch:new-branch-origin
Push: new-branch:new-branch
}}}
The first says "map the remote new-branch to new-branch-origin in the local repository".  The second says "when pushing code, push from new-branch locally into new-branch remotely".  If you haven't set any Push: lines, then git implies a "master:master" mapping for pushes.  Once we add our new-branch push line, we also have to addm aster:master if you intend to ever commit to master.

Now, you're set up for committing and pushing the branch.  There's one more trick to know about.  When you do "git pull", it is now pulling the remote branches into what they're mapped to locally.  So, the latest new-branch upstream code is in new-branch-origin.  To merge it to your local new-branch code, do:

{{{git pull . new-branch-origin}}}

This means "merge the new-branch-origin code into the current working directory".  Like the other git pull command we mentioned, it will by default commit the merge, unless it runs into conflicts which aren't automatically resolvable.

And, to push, you do it just like when you were working on master.

{{{git push origin}}}

I think that should be it for this guide.  Please feel free to edit for grammar, and send questions to me (anholt on #freedesktop) --EricAnholt
 
