Several X.Org projects have been moved to the git revision control system.  While there exist tutorials out there for using git, one of git's features is that it allows people to use many different workflows, so many of those tutorials won't apply to git as it's used in X.Org projects.  We might call what we usually do "shared central repository" mode.

Things which are within the scope of this document:
 * Checking out code
 * Committing code
 * Resolving conflicts
 * Working on branches

Things which are not within the scope of this document:
 * Using the index for selective committing
 * Maintaining public personal repositories

First note about git: there are many commands.  Each command exists as an argument to the git command ("git clone") and also as a hyphenated version to aid in tab-completion ("git-clone").

The next thing to understand is that when you check out code from a remote git repository, you end up with a full-fledged git repository yourself.  When you diff, commit, etc. code, you are doing it against your local repository.  Clone, pull, and push are used to move changes between repositories.  Your local repository is stored in the .git directory at the top of the tree.

== Checking out repositories ==

To initially check out a repository, you use git clone. You can see what repositories are available by [http://gitweb.freedesktop.org/ browsing].  The format for the URL to clone for components is: 

{{{
git://anongit.freedesktop.org/git/xorg/{app,driver,lib,proto}/<module>
}}} 

and for the X server

{{{
git://anongit.freedesktop.org/git/xorg/xserver
}}}

Note that gitweb confusingly displays all 'slashes' as 'dashes'; the module name should be given literally ('dashes' as 'dashes') but the path to the module needs 'dash' to 'slash' replacement.

An example for xorg-lib-libX11:

{{{ git clone git://anongit.freedesktop.org/git/xorg/lib/libX11 }}}

and another for a driver:

{{{ git clone git://anongit.freedesktop.org/git/xorg/driver/xf86-video-intel }}}

This will create a directory: xf86-video-intel

You can also append a directory path to be created that mirrors that of the repository:

{{{ git clone git://anongit.freedesktop.org/git/xorg/driver/xf86-video-intel xorg/driver/xf86-video-intel }}}

The git:// protocol is fast, but is read-only.  Pushing requires ssh, so if you're a developer, you would use:

{{{ git clone ssh://git.freedesktop.org/git/xorg/lib/libX11 }}}

If you become a developer at a later time, you can edit {{{.git/remotes/origin}}} and replace the contents of the {{{URL: }}} line.

If your username at freedesktop.org is different from local, the refspec becomes {{{ ssh://myusername@git.freedesktop.org/git/xorg/lib/libX11 }}}, or you can just add the following to ~/.ssh/config to tell ssh your default username for all of freedesktop.org:

{{{
Host *.freedesktop.org
        User myusername
}}}
If you cannot use the git protocol to fetch the repository, it is also available via http, although that is significantly less efficient. Change the above commands to look like:

{{{ git clone http://anongit.freedesktop.org/git/xorg/lib/libX11.git }}}

Note the trailing '.git' and the substitution of http: for git:. The result will be placed in libX11 (without a trailing .git).

For information about which Xorg modules have been moved to GIT. See [http://wiki.x.org/wiki/GitPage GitPage] for more information.

== Viewing diffs ==
Now, you have a copy of the master branch of the tree.  Go ahead and build it and whatever else.  If you make some changes, you can see what files you would commit with
{{{ git status -a }}}
or get a diff of the local tree against the repository with
{{{ git status -a -v}}}

The {{{-a}}} flag means all local updates.  The git system actually has this concept of an "index", managed using git-update-index, which lets you selectively commit changes.  However, because this adds to confusion, I will leave learning about the index up to you to do later.

== Getting the latest upstream code ==
There are two ways to update your local repository. Which one to use depends on whether you have committed changes in the meantime.

=== No changes: pull ===
The command to update your local repository is:

{{{git pull}}}

It will pull down the latest repository information from the {{{origin}}} remote file (which points at where you initially cloned the repository from), then merge.  If the new changes don't conflict with anything locally, the merge will "fast-forward" your branch reference to the new head.  If new changes do conflict, it will try to do an automatic merge using a couple of different schemes, and then automatically commits the merge if it's satisfied.  If you notice that your pull resulted in a merge (in the output of pull), you might want to use {{{gitk}}} to see if the merge did what you expected it to.  If it isn't satisfied, then you have to resolve the conflict manually.

=== You've made changes: fetch and rebase ===
If you have committed local changes, then {{{git-pull}}} will create a spurious "Merge" commit, which will pollute the change list when you later push upstream. To avoid this, do these two commands:
{{{
git fetch
git rebase origin
}}}
Instead of merging, this attempts to insert the changes you pull from the origin repository before your local changes, avoiding the merge message.

== Dealing with conflicts ==
If you get a serious conflict that can't be merged automatically, git will leave familiar conflict markers in the files, and {{{ git status }}} should say that you've got unmerged files.  Go edit them and fix your conflicts, and test.  After you do so, {{{git status}}} will still be noisy about unmerged files (since you haven't updated the index to say you've merged them), but you can still do

{{{git commit -a}}}

and commit your merge.  It hands you a default log message for the merge, and it will retain the information on the parents of the commit you did, so that branch history is maintained.

== Reverting commits ==
It may happen that you commit something you really didn't want to go into the repository.  This is not referring to broken changes, but things like mis-merges or getting branches confused.  If you haven't pushed the code upstream, then it's really easy to make it look like the commit didn't happen.  To reset to the immediate previous revision, you would run:

{{{git reset --hard HEAD^}}}

== Reverting code prior to commit ==
git doesn't have a revert command like svn. Instead, just run {{{git checkout -- <yourfile>}}} to revert it to the last committed version. The {{{--}}} isn't necessary in most cases, but does provide extra insurance.

== Committing code ==
If you're satisfied with your diff, you could commit it with:
{{{git commit -a}}}

After you enter your log message, it will quickly terminate.  You've now committed your diff to your local repository.  You could run:

{{{gitk}}}

to see your diff in the history now.  Note that the {{{gitk}}} output actually shows two branches: master and origin.  The "master" branch is the head of development in the local tree.  The "origin" branch is the last version from upstream.

== Pushing your code upstream ==

Now that you've resolved the conflicts (if any) with others upstream, you're ready to push your changes.  To do this, type

{{{git push origin}}}

This tells git to push every branch in a "Push:" line in the "origin" remote upstream (more on the Push: lines later).  Unlike git pull, git push does require you to specify the remote and doesn't have a default.

== Working on branches ==
Now you've learned how to check out HEAD code, diff, update, commit, and push code back upstream.  The next thing to talk about is branching.

You can see what branch you're on using "git branch" -- it should show "master" initially.  To switch branches in your current repository, do:

{{{git checkout <branch>}}}

If you've got local changes, there are flags to either throw out your local changes, or try to merge them across to the new branch.  By default it will just refuse to change.

If you want to make a new branch, you can do:

{{{git checkout -b <new-branch>}}}

Now you've got a new branch.  However, git checkout doesn't set up the branch: branch-origin mapping that we want.  There's a rule in using git, which is: '''Never commit to the right side of a Pull line'''.  This is referring to the contents of .git/remotes/<remotename>.  The .git/remotes/origin (what you're using currently) file should currently have:
{{{
URL: git://anongit.freedesktop.org/git/whatever
Pull: master:origin
}}}

This means that the current remote master is mapped to the local origin.  When working on a branch where you'll be committing code, add a few more lines:
{{{
Push: master:master
Pull: new-branch:new-branch-origin
Push: new-branch:new-branch
}}}
The first says "map the remote new-branch to new-branch-origin in the local repository".  The second says "when pushing code, push from new-branch locally into new-branch remotely".  If you haven't set any Push: lines, then git implies a "master:master" mapping for pushes.  Once we add our new-branch push line, we also have to add master:master if you intend to ever commit to master.

Now, you're set up for committing and pushing the branch.  There's one more trick to know about.  When you do "git pull", it is now pulling the remote branches into what they're mapped to locally.  So, the latest new-branch upstream code is in new-branch-origin.  To merge it to your local new-branch code, do:

{{{git pull . new-branch-origin}}}

This means "merge the new-branch-origin code into the current working directory".  Like the other git pull command we mentioned, it will by default commit the merge, unless it runs into conflicts which aren't automatically resolvable.

And, to push, you do it just like when you were working on master.

{{{git push origin}}}

I think that should be it for this guide.  Please feel free to edit for grammar, and send questions to me (anholt on #freedesktop) --EricAnholt

== Using Git ==

''The following was from [http://xcb.freedesktop.org/ XCB]'s wiki. Feel free to integrate.''

Git is a powerful SCM started by Linus Torvalds as a tool to handle the Linux Kernel development. You can download it from [http://www.kernel.org/pub/software/scm/git/ http://www.kernel.org/pub/software/scm/git/]. To learn how to use git, you can read the [http://www.kernel.org/pub/software/scm/git/docs/core-tutorial.html short tutorial], the [http://www.kernel.org/pub/software/scm/git/docs/ full documentation] (included with git as man pages) or Jeff's Garzik [http://linux.yyz.us/git-howto.html Kernel-hacker howto] (which was written for kernel developers but it's useful for any project).

This is a quick guide for users (not developers, developers are recommended to read the previous documentation). First of all, you need to [http://www.kernel.org/pub/software/scm/git/ install GIT] (it's already available in many distros, including Debian and Gentoo).  Make sure you have at least version 1.2 of GIT; older versions have problems.

  * How to get a copy of xcb/libX11:
   * `git clone git://anongit.freedesktop.org/git/xcb` (this will create an 'xcb' directory in the working directory)
   * `git clone git://anongit.freedesktop.org/git/xorg/lib/libX11` (same for libX11)
   * git will create a `.git` directory inside the source directory where it stores all the info

  * How to check for updates:
   * Go to the directory where you have your xcb/libX11 sources and type: `git pull`. This will download and apply updates to your local repository.

  * How to create a branch from given tag or commit id:
   * `git checkout -b newbranchname tagname-or-commit-id` (you can see all the available tags doing `ls .git/refs/tags`; commit ids are SHA1 values)

  * How to switch to an existing branch:
   * `git checkout branchname` (you can see the available branches with `git branch`, which will also tell you which branch you are currently on)

  * How to switch back to 'head':
   * `git checkout master`

  * Bisection search:
   * This a brute-force but very useful method to find out what change causes a given bug, specially if you are not a developer and you know (neither you want to know) nothing about what is going on in the code. You tell git what was the last version that worked, the first version where you noticed the bug (of course you need to have a reproducible bug in order to do this ), and git will set your repository to a state somewhere in the middle of those two 'points'. After testing it, you tell git if the bug is there or not, and git will set your repository to another state which is closer to the bug. After compiling and testing a few revisions, git will be able to tell you what commit causes the bug. For example, let's say I found a reproducible bug in libX11 between the XORG-6_8_1 tag and XORG-6_8_99_9 (cd libX11; ls .git/refs/tags).
   * Tell git to start bisection search: `git bisect start`
   * Tell git about the bad version: `git bisect bad XORG-6_8_99_9`
   * Tell git about the good version: `git bisect good XORG-6_8_1`
   * Compile and test. Is the bug there? Type `git bisect bad` Everything works well? Type `git bisect good`. Git will tell you how many revisions you need to test.
   * If you can't test a given 'state' (ej: git bisection put all your sources in a state somewhere in the middle of a merge and it doesn't compile) type `git bisect good/bad` and git will give you another 'state' to test.
   * More details and tricks at [http://www.kernel.org/pub/software/scm/git/docs/howto/isolate-bugs-with-bisect.txt http://www.kernel.org/pub/software/scm/git/docs/howto/isolate-bugs-with-bisect.txt]
  * To summarize and extend a bit, here's Josh's quick translations of CVS commands:
   * `cvs checkout` &#8594; `git-clone git+ssh://git.freedesktop.org/git/xcb`
   * `cvs add file` &#8594; `git-add file`
   * `cvs status` &#8594; `git-status -a`
   * `cvs diff` &#8594; `git-status -a -v`
   * `cvs commit` &#8594; `git-commit -a ; git-push origin`
   * `cvs update` &#8594; `git-pull`

  * If you feel curious about git, don't forget Jeff's Garzik [http://linux.yyz.us/git-howto.html howto], the [http://www.kernel.org/pub/software/scm/git/docs/core-tutorial.html short tutorial] and the [http://www.kernel.org/pub/software/scm/git/docs/ full documentation] (included as man pages)

==== Editorial Comments ====

Things I find unintuitive in git that I think ought to be fixed:
 * the index should be second-class, i.e. no -a flags to avoid the index.
 * branch:branch-origin (or something) should be the default pull.
 * branch:branch should be the default push for all branches, but only push the current branch unless a flag is added
 * an update command should be created that:
  * fetches the current branch's upstream to its -origin locally (or all branches, perhaps)
  * merges the current branch origin to the branch locally
  * commits if it was a fast-forward, and leaves uncommitted diffs otherwise.


