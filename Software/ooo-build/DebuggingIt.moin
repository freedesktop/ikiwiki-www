<<TableOfContents>>

== Before you start ==

You need a ''linked'' build - please have a look at the [[Software/ooo-build/HackingIt|HackingIt]] pages, and install either using the `make dev-install`, or `bin/ooinstall -l`.

== gdb minimum ==

These instructions are mostly Linux (gdb) related, for Windows, you might consult [[http://wiki.services.openoffice.org/wiki/Windows_Debugging|this page]].  gdb is a powerful tool, but it pays off to get familiar with it a bit.

=== Recommended .gdbinit file ===

You can define macros that help you eg. examine OOo strings in your `~/.gdbinit` file, so that they are always available.  We recommend at least the following contents:
{{{
set history filename ~/.gdbhistory
set history save on

handle SIGPWR nostop noprint
handle SIGXCPU nostop noprint
handle SIG33 nostop noprint

tabset 4

# define "pu" command to display sal_Unicode *
def pu
  set $uni = $arg0
  set $len = $arg1
  set $i = 0
  printf "\""
  while (*$uni && $i++<$len && $i<255)
    if (*$uni < 0x80)
      printf "%c", *(char*)$uni++
    else
      printf "\\x%x", *(short*)$uni++
    end
  end
  printf "\"\n"
end

# define "pus" command to display rtl_uString
def pus
  set $ns = $arg0
  if ($ns.buffer)
    pu $ns.buffer $ns.length
  else
    print "Invalid/non-initialized rtl_uString."
  end
end

# define "pou" command to display rtl::OUString
def pou
  set $ns = $arg0
  if ($ns.pData)
    pus $ns.pData
  else
    print "Invalid/non-initialized OUString."
  end
end

# define "ptu" command to display tools (Uni)String
def ptu
  set $ns = $arg0
  if ($ns.mpData)
    pu $ns.mpData->maStr $ns.mpData->mnLen
  else
    print "Invalid/non-initialized tools String."
  end
end
}}}

If you want to define your own macros, please remember that gdb only has global variables.

=== TUI ===

One of the less known gdb features is its text user interface.  Instead of plain `gdb`, use `gdb --tui` every time you want to debug.  You will be able to see the context of what are you debugging all the time.  Useful commands:

 * '''Ctrl-l''' - refresh screen (when something prints there, etc.
 * '''Ctrl-x s''' - single key mode.  In this mode `n` means `next`, `s` `step`, `r` `run`, and few more.  To get the 'normal' gdb input line, press `space`, and start typing, like ` print whatever_variable`.  `q` exits the single key mode

=== Intercepting exceptions ===

When you want your code to stop whenever an exception is raised, do:
{{{
(gdb) catch throw
}}}

Alternatively, you can do `break __cxa_throw`.  More info in [[http://kohei.us/2009/12/22/setting-break-point-where-an-exception-is-thrown/|Kohei's blog]].

== Start debugging ==

Now, when you have setup your `.gdbinit`, you can start debugging:
{{{
# change directory to the installation provided by make dev-install
cd build/install/program
source ooenv
gdb --tui ./soffice.bin
(gdb) run -writer
}}}

== How to get the symbols ==

You soon realize that you have no debugging symbols in your build.  Let's say, you need symbols for `vcl` - then you need to completely rebuild `vcl` using `build debug=true`, instead of `build`, like:
{{{
cd build/ooo320-m12/vcl
# remove the old build
rm -r unxlngi6.pro
# setup the build environment
source ../LinuxX86Env.Set.sh
# and build
build debug=true
}}}

== Sw ==

=== Dumping SfxItemSet objects: ===
{{{
define dump_pSfxItemSet
   printf "count=%i\n", $arg0->_nCount
   set $is_i=0
   set $is_k=0
   while($arg0->_pWhichRanges[$is_i]!=0)
      printf "[%i; %i]\n", $arg0->_pWhichRanges[$is_i], $arg0->_pWhichRanges[$is_i+1]
      set $is_j=$arg0->_pWhichRanges[$is_i]
      while($is_j<=$arg0->_pWhichRanges[$is_i+1])
         if ($arg0->_aItems[$is_k]!=0)
            printf "%i %i %p\n", $is_k, $is_j, $arg0->_aItems[$is_k]
         end
         set $is_j++ 
         set $is_k++
      end
      set $is_i=$is_i+2
   end
end
}}}


=== Dumping the nodes structure ===

This functions doesn't seem to be friendly with ''set print object'' or ''set print pretty''.
{{{
define pIndent
  set $level = $arg0
  set $iLevel = 0
  while ( $iLevel < $level )
    printf "\t"
    set $iLevel = $iLevel + 1
  end
end

define pNodeType
    if ($sw_node->nNodeType==1)
        printf "ND_ENDNODE "
    end 
    if ($sw_node->nNodeType==2)
        printf "ND_STARTNODE "
    end
    if ($sw_node->nNodeType==6)
        printf "ND_TABLENODE "
    end
    if ($sw_node->nNodeType==8)
        printf "ND_TEXTNODE "
    end
    if ($sw_node->nNodeType==0x10)
        printf "ND_GRFNODE "
    end
    if ($sw_node->nNodeType==0x20)
        printf "ND_OLENODE "
    end
    if ($sw_node->nNodeType==0x38)
        printf "ND_CONTENTNODE "
    end
    if ($sw_node->nNodeType==0x30)
        printf "ND_NOTXTNODE "
    end
    if ($sw_node->nNodeType==0x42)
        printf "ND_SECTIONNODE "
    end
end


define dump_pSwUndo
  set $su_i=0
  while ($su_i<$arg0->nA)
    set $su_n=((SwUndo**)($arg0->pData))[$su_i]
    printf "%i %p %i\n", $su_i, $su_n, $su_n->nId
    set $su_i++
  end
end

define pNodesArr
  set $sw_size = $arg0->nSize
  set $iNodes = 0
  set $indent = 0
  while ( $iNodes++<$sw_size && $iNodes<255 )
    set $sw_node=$arg0[$iNodes-1]

    if ( $sw_node->nNodeType == 1 )
        set $indent = $indent - 1
    end

    pIndent $indent

    printf "%d ", $iNodes - 1
    pNodeType

    if ( $sw_node->nNodeType == 2 || $sw_node->nNodeType == 6 )
        printf ", EoS: %d", $sw_node->GetStartNode( )->pEndOfSection->nOffset
        set $indent = $indent + 1
    end
    
    if ( $sw_node->IsTxtNode( ) )
        printf ", Text: "
        set $sw_txt = $sw_node->GetTxtNode( )->aText
        ptu $sw_txt
    else
        printf "\n"
    end
  end
end
}}}
