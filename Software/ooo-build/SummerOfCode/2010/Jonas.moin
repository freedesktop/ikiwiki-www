''This page contains notes, plan and other information relevant to Jonas' GSoC project for improvement of Open``Office equation editor.''

<<TableOfContents()>>

If page should be named differently or moved to another wiki, or if you have questions I can be contacted by e-mail <jopsen at gmail dot com>.
My orginal GSoC proposal for this project can be found here: http://lists.freedesktop.org/archives/ooo-build/2010-April/000771.html

= Project description =
Improvement of the visual equation editor for Open``Office, by seperating the visual cursor from the text cursor, and handling keyboard input with the visual editor. Thus giving the user an equation editor similar to Math``Type, LyX, KFormula, Math``Cad etc...

= Project plan =
''A breif overview of the steps I intend to take, in order to complete this project, more task will likely occur as the project progresses.''

== Bonding period ==
 *Analyze nodes and how they are composed (write notes)
 *Determine new representation of cursor position
 *Figure out how to draw the cursor
== Before mid-term ==
 *Make Sm``Graphic``Window grab focus and accept input
 *Disable synchronization with Sm``Edit``Window
 *Start implementing methods or visitors for handling movement
== After mid-term ==
 *Enable the cursor to move within the characters of a node
 *Handle tree modifying input, delete, insert character etc...
 *Enable selections, copy, cut, paste, delete etc.
 *Improve user experience... and finish details.

= About me =
I'm Jonas Finnemann Jensen, student at AAU in Denmark. I'm working on Go Open``Office for GSoC 2010. For more info ask me or see http://jopsen.dk/blog/.

= Notes =
''I'll notes on anything useful I discover as a part of this project here, some of it may be useful to others hacking on StarMath later.''

== Notes on Nodes ==
Having made a patch to dump equation tree to graphs using graphviz, I figured I'd post a few examples here... I'll also use these equations as test vectors whenever something is needed. More test vectors, to cover all cases, may be needed later for now these will do.

I've included screenshots of the equations here. But only linked to the dumps, as these are rather large. The number on the edges in the graph denotes the subnode number, e.g. the number given to GetSubNode in the parent.

The patch for making these dumps can be [[http://jopsen.dk/downloads/GSoC2010/StarMath-DumpAsDot.diff|downloaded here]]. You enter a formula, render it, in StarMath, and click on the rendered equation, and hit enter. The dump is saved to /tmp/smath-dump.gv enjoy...

=== Equation 1 ===
{{{
a+3 over 2+ {sqrt{5+4} over {3^2  + 2^5}}
}}}
{{http://jopsen.dk/downloads/GSoC2010/eq1.png}}

[[http://jopsen.dk/downloads/GSoC2010/graph1.png|Graph as png]] or  [[http://jopsen.dk/downloads/GSoC2010/dump1.gv|Graph in dot format]].

=== Equation 2 ===
{{{
left ( int from{a} to{b} x^2 dx  right ) ^2 = a^2 left( x- x^2 right)^2 
}}}
{{http://jopsen.dk/downloads/GSoC2010/eq2.png}}

[[http://jopsen.dk/downloads/GSoC2010/graph2.png|Graph as png]] or  [[http://jopsen.dk/downloads/GSoC2010/dump2.gv|Graph in dot format]].

=== Equation 3 ===
{{{
log_b(x) = {log_k(x)} over {log_k(b)}
}}}
{{http://jopsen.dk/downloads/GSoC2010/eq3.png}}

[[http://jopsen.dk/downloads/GSoC2010/graph3.png|Graph as png]] or  [[http://jopsen.dk/downloads/GSoC2010/dump3.gv|Graph in dot format]].

=== Equation 4 ===
{{{
left [ matrix{1 # 0 # 2 ## -1 # 3 # 1}   right ] times 
left [ matrix{3 # 1 ## 2 # 1 ## 1 # 0}   right ]  =
left [ matrix{5# 1 ## 4 # 2}   right ]  
}}}
{{http://jopsen.dk/downloads/GSoC2010/eq4.png}}

[[http://jopsen.dk/downloads/GSoC2010/graph4.png|Graph as png]] or  [[http://jopsen.dk/downloads/GSoC2010/dump4.gv|Graph in dot format]].

=== Equation 5 ===
{{{
lbrace 1,2,2 over 4 rbrace subset setQ newline
lbrace 1, 2, 3 rbrace nsubset setZ
}}} 
{{http://jopsen.dk/downloads/GSoC2010/eq5.png}}

[[http://jopsen.dk/downloads/GSoC2010/graph5.png|Graph as png]] or  [[http://jopsen.dk/downloads/GSoC2010/dump5.gv|Graph in dot format]].

== Caret Movement ==
The problem with caret movement is to compute the next caret position in a given direction using the current
caret position.

A caret position can be defined as a node and an index within this node:
{{{
struct SmCaretPos{SmNode* pSelectedNode; int index};
}}}

 Note:: this index does not denote subnode of the selected node. However, it can be used by nodes such as text node, in order to let the cursor exist within such node.

Using this definition of a caret position, we can discus methods for computation of caret movement.

=== Approach 1: Intelligent Tree Searching ===

The idea behind this approach is to do intelligent tree traversal in order to find the next caret position.
To implement this approach we'll need to define a complex visitor for each direction of movement: left, right, up
and down. The methods on this visitor will take a !SmCaretPos as parameter, and will return a !SmCaretPos.

Consider this pseudo implementation of a method in the visitor for computing a movement to the right:
{{{
SmCaretPos RightMovementVisitor::visit(SmXXXNode* curNode, SmCaretPos param){
                                      //Where SmXXXNode is a derivation of SmNode
    if(param.pSelectedNode == NULL){
        //We will move within this node using index
        //if not possible we will move out of this node by calling the parent:
        return curNode->GetParent()->accept(this, SmCaretPos(curNode, -1));
    }else if(param.pSelectedNode == curNode->GetParent()){
        //We will move into this node from the given direction.
        //i.e. return left-most child, or curNode doesn't have children return curNode and left-most index
        //for the RightMovementVisitor
    }else{
        //We will move out of a child of curNode, and select the next child after param.pSelectedNode
        //By next I mean the child to the right of param.pSelectedNode for the RightMovementVisitor.
        //If no such child is available we will move of this node by calling the parent:
        return curNode->GetParent()->accept(this, SmCaretPos(curNode, -1)); 
    }
}
}}}
The above can hardly be called pseudo-code, however, the comments should give an idea to the in-variants.
Basic idea is that if pSelectedNode is NULL, then we will choose the next index if possible, or ask the parent to move out of the current node. If pSelectedNode is the parent node, then it is because the parent is trying to move into the current node, thus return current node if it is visible otherwise ask a child node. If pSelectedNode is not NULL and not the parent node, then it is a child node of the current node; and we should try to move into the next child or ask the parent to handle it.

With a visitor like this, the next caret position to the right can be determined using:
{{{
SmCaretPos start_param(NULL, -1);
RightMovementVisitor v;
currentCaretPos = currentCaretPos.pSelectedNode->accept(&v, start_param);
//Now draw: currentCaretPos
}}}

=== Approach 2: Closest Caret Position Search ===

The idea in this approach is to suggest all possible caret positions, and select the closes caret position
in the desired direction. This can be implemented using an abstract visitor, that suggests caret positions
to template methods. Concrete implementation of this visitor then saves the suggested caret positions
they are interested in.

Pseudo-implementation:
{{{
class MovementVisitor : public Visitor{
    virtual void suggest(SmCaretPos caret, Point pos) = 0;
    void visit(SmXXXNode* node){     //This is an implementation of an abstract method from the Visitor class
        if(node->IsVisible()){
            suggest(SmCaretPos(node, 0), node->GetCenter());
            //When implementing an I-beam caret, don't use center...
        }else{
            //Visit all the children
            for(each child) {
                child->accept(this);
            }
        }
    }
};

class RightMovementVisitor : MovementVisitor{
    RightMovementVisitor(Point from_pos) { this->from_pos = from_pos; }
    Point from_pos;
    Point best_pos;
    SmCaretPos best_caret;
    suggest(SmCaretPos caret, Point pos){
        //If the suggested caret position is to the right of the position we're moving from:
        if(pos.X() > from_pos.X()){
            //If pos is closer to what we're moving from than best_pos:
            if((pos - from_pos).distance() < (best_pos - from_pos).distance()){
                //Choose caret and pos to be the best suggestion offered so far...
                best_caret = caret;
                best_pos = pos;
            }
        }
    }
};
}}}

With this approach, implementing a visitor for moving up, down, and left is almost trivial. Also these
position search visitors, can also be used for handling mouse clicks.
Using visitors such as above the next right position can be easily computed as:

{{{
RightMovementVisitor v(currentCaretPosPoint);
GetFormulaTree()->accept(&v);           //Notice that we search the entire tree!
currentCaretPos = v.best_caret;
currentCaretPosPoint = v.best_pos;
//Now draw: currentCaretPos
}}}

Note that this approach searches the entire tree, however, the square roots in the distance computations
can be omitted, because we only need to compare. It can also be optimized so that entire subtrees are not
searched if their bounding box (the structure node that holds them) are placed so that they cannot offer a
better caret position than what have already been suggested.
Also equation trees are usually quite small, e.g. doesn't spand multiple pages. And even if so, axis 
aligned bounding boxes performs very well in practical implementations.

It obvious that this the condition:
{{{
    (pos - from_pos).distance() < (best_pos - from_pos).distance()
}}}
Can be improved. For instance when moving right, distance different on the Y axis could be multiplied with
two, in order to favor caret position on the same line as the current position.
A more complex algorithm for doing this, might help solve ackward cases. And note that such an algorithm
would not something that needs to be updated when new nodes are added.

=== Pros and cons ===
''A list of pro and cons for the two approaches.''

==== Pros for approach 1 ====
 * It is efficient, e.g. not a wide-expensive-search
 * It's a predictable for the user. Consider the equation:
{{{
             2
            a  + b              code for equation: a^2 + b
}}}
  If we decide that the next position from "a" when moving right is "+". Then it will not 
  suddenly select "2" in an equation like:
{{{
             2 + c
            a      + b          code for equation: a^{2+c}+b
}}}
  Where the exponent is closer to "a" than "b" is...
  So it can be argued that this offers more predictable behavior for the user. However, if the
  exponent is sufficiently large it can be argued that the user will expect the cursor to move
  into the exponent instead. I don't know if users imagine the tree behind the editor and expects
  movement to operate accordingly.
  Nevertheless, this illutrates an example of how approach 1 differs from approach 2. And there
  can propably be argued for both approaches, from a usability point of view.


==== Cons for approach 1 ====
 * It's hard to maintain! It will require four complex visitors inorder to do movement, and each of these will need a special method for each node. Sometime the parsing context in which the node appears need to be taken into consideration too! Nevertheless, adding new nodes to the editor will become harder with this approach because they will need to be worked into four complex visitors.
 * It will not move to the closes position, consider this equation:
{{{
        a  +  a  +  a 
         1     2     n
        --------------
              b                 code for equation: {a_1 + a_2 + a_n} over b
}}}
  If "b" is selected it is unlikely that "2" will be selected when moving up. Using approach 2, this
  would happen easily. A complex hack that combines stuff from approach 2, to solve this might be
  possible, but it would also be harder to maintain.
 * Bugs are likely to be serious, a bug in this approach could very easily result in infinite recursion, given a rare equation subtree.

==== Pros for approach 2 ====
 * It's maintainable: Instead of four complex visitors, we will only need one: the MovementVisitor. And even this is in most cases rather simple. But adding a new Node will only require modifications to this visitor.
 * It's reusable for handling mouse clicks, i.e. finding the caret position closest to a click.
 * It selects the caret position that is visually closest, not logically.

==== Cons for approach 2 ====
 * It's more expensive, however, requires less code, thus smaller binary, which might have just a big a positive performance implication as the more efficient search.
 * It's not logically predictable...

=== Summary ===
We need to figure out which approach is best in terms of maintainability and usability. It's obvious to me that
approach 2, offers the easiest maintainability. And I believe that it is possible to define the condition, i.e.
the distance computation algorithm so that result becomes reasonable.
However, if we do want a strict behaviour in terms of how nodes are composed, approach 2 is the way to go.
But again this is visual movement, thus strict behaviour according the composition of nodes is not necessarily always desired, so maybe the solution is to enhance approach 2, with some of the ideas from approach 1.

Current status, is that I have approach 2 working for all directions, however, it does have a few abnormalities, likely because I'm not using I-beam, but a selection around the entire selected node.
I've also got a somewhat working implementation of approach 1, for left movement, but it still lacks many specific nodes and is not working very well at the moment.
Anyway, a solution could be to go forward with a better implementation of approach 2, and if that doesn't work out nicely at the end, well then it can always be replaced later.

= External links =
''Information that might be relevant for hacking StarMath.''
 * [[http://wiki.ooo4kids.org/index.php/ImproveMathEquationEditor | ImproveMathEquationEditor on wiki.ooo4kids.org and sub-pages]]

= Log/progress report =
''On request of my mentor, I'll be posting progress reports here as often as possible.''

== Monday the 31th of May ==
I've been writing notes on the two approaches to computing the next position for visual movement... I've also gotten the first approach stuff, that didn't work yesterday working, but the implementation is still so partial that it's almost not worth testing out. Anyway, I'll publish my patch, e.g. the combined patch of all my nasty hacks, and send a link to the notes to my mentor(s).

== Sunday the 30th of May ==
I've been testing out the visual movement I implemented friday, and trying to improve it. Then I've also worked on the first approach, e.g. my initial idea, it's a bit more complicated, but yield more predictable results... Nevertheless, at the current stage my quick-n-dirty implementation didn't work. I'll try to bugfix it later, also I'll make some pretty pictures to explain the two approaches, with pros and cons.

== Friday the 28th of May ==
I had a some trouble sleeping last night... It might be slightly related to the fact that I had an epiphany: Instead of making complex rules about how to find the next caret position, based on Sm``Node type and information about context from the parser, I define a set of Caret``Position within each node and let a visitor search for a position to the left of the current caret position.

I tried it out today and works pretty good, I didn't do a beam caret yet... I'd expect better results with that. I'll try it this weekend, if I can find time. It's a different approach, I'll do an outline with pro/cons (and explanatory pictures) later... And pass the question on to my mentor(s).
Anyway, this approach could be easier to implement and maintain while offering better navigation, the ladder might be subjective.

== Thursday the 27 of May ==
I got the visitor working today. And have been analyzing the parser... to get a more specific idea of how nodes are composed... I'm also starting to consider using the parsing information, specifically SmToken on SmNode, to assist the visitor. As one movement pattern based on the visitor alone won't cut it. 

== Wednesday the 26th of May ==
Today I've been writing a visitor... This was slightly complicated by the fact that a copy constructor of SmStructureNode creates an instance of SmNode, which I've tried to make abstract... Furthermore I felt unable to detect where this copy constructor was defined... There was nothing helpful in the definition of SmNode, and though SmRect has one, it's declared inline and doesn't have body in the definition. I tried debugging it, but the copy constructor of SmStructureNode wasn't invoked, it's probably only used in some special corner cases...

Anyway, I also wrote a small test visitor filled with assertions and trying to accept it generates a segmentation fault, that the debugger weren't too happy helping me with. Maybe I should try raw gdb, i.e. without frontend, and see if that helps. Alternately I'll probably just dump some strings to cerr and locate the crash.
But I'll be fixing the visitor tomorrow... Where, by the way, I'll be working on GSoC all day, since I just handed my semester project in for printing today :)

== Tuesday the 25th of May ==
Today I learned that printing stuff from functions helps detect when it executes the wrong branch, also KeyInput behaved inappropriately when {{{GetCode()}}} was called multiple times... That is handling key input with a switch worked fine, but doing to with if-statments didn't work... I'm still having problems writing integers to streams, e.g. cerr<<45 doesn't work... It works find for strings, but integers won't work and just blocks the stream. This is really annoying, because dumping information to stderr is easier and often faster than setting up breakpoints and reading variables in the debugger. Also information dumps can be persisted between sessions even though line numbers change.

Status, I've cursor movement... By using the keyboard I can select any node in the equation tree. The movement is still naive, e.g. it just moves between subnodes in the order they have. Next step is to implement visitors and make the movement more intelligent. I've also got to decide where the code for input handling should be placed, e.g. in SmGraphicWindow where KeyInput is or where the equation tree is managed. Perhaps it would be best to place tree related stuff in the SmDocShell, and handle input in SmGraphicWindow, I'll have to look into to this...

== Monday the 24th of May ==
Had trouble with my build, so decided that it was easier to just start over... Delete my go-oo checkout, created a new from a stable branch and typed {{{ $ make ; totem ring.mp3}}} and went back to working on the semester project I'm handing in Thursday :)
Then suddenly it rang, and now I have a working checkout again...

== Sunday the 23th of May ==
The past week I've been working to get the cursor moving... I'm having minor problems with KeyInput and caret position calculation... And decided that I wanted to enable assertions to help find the bugs. So I spend this evening trying to enable assertions with:
{{{
$ ./configure --with-distro=UbuntuKarmic  --with-git --with-gcc-speedup=ccache --with-num-cpus=4 --disable-kde --disable-kde4 --enable-dbgutil
$ make
}}}
This would build, after fixing a bad cast in testtools this module build, however, the connection module wouldn't build either, something about: {{{_STLD::__stl_debug_engine<bool>()}}} being undefined... Anyway, my guess is that it doesn't link against libstlport_debug, there's a problem with the library I have installed or something else is bad.
Nevertheless, I decided that it was too far out of my scope and likely fixed if I updated, either go-oo or my distro (Ubuntu). So I configured without --enable-dbgutil and it doesn't work... So now I'm going to bed, leaving that headache for an other day.

== Sunday the 9th of May ==
Since the meeting Friday ([[http://wiki.ooo4kids.org/index.php/ImproveMathEquationEditor/IRCMeetings/May2010/7th_May2010|log here]]) I've built Star``Math with debug symbols... Also tried to activiate SM_RECT_DEBUG for visual debug information, not really useful for my project, and by the way SM_RECT_DEBUG needs to be defined in rect.hxx not node.cxx where it is mentioned.
I have played a bit with the debugger, I used beaverdbg to get a nice GUI (sorry I'm too lazy to learn raw gdb)...

Furthermore I've tried to make Sm``Graphic``Window grab focus and handled KeyInput in view.cxx. Well, Now that I had this Key``Input I had to use it for something :)
So I wrote a simple method on Sm``Node for dumping the entire equation tree to a dot-graph (for graphviz), and used Key``Input to do the dump. The graphs gives a pretty good overview of how the nodes are composed... I've published a few graphs under the notes section.
I've also given all Sm``Node a parent node, which is NULL for the root, this made it easier to make the graph and is probably going to be necessary later anyway...

And by the way, writing an int to std::cout or an ordinary file stream doesn't work in StarMath. If you write my_fstream<<"A number: "<<42<<" will not be written"; neither 42 or anything written to the fstream afterwards will be written. I've heard that std::cerr should work, but that's not useful for dumping information to files. I did a nasty workaround using sprintf...
