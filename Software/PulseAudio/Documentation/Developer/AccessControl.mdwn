# Access Control

## Introduction
Since MIT's introduction of time-sharing in the 60s,¹ operating system's security was classically designed around the user: how to protect a user's applications, time quota, storage quota, and his or her own data, from many other users actively using the very same system.

This user-centric model of security was later inherited into the Personal Computing era, with slight differences. Applications written over the Wintel platform expected full access to the user's data, network, and even other applications files and data. By late 2008, the iPhone shifted the client applications landscape by forcing each application to run _only_ in its own isolated sandbox. By 2012, Docker similarly changed the server side of the equation by mainstreaming application-centric containers and deployment.

The concept of user-centric security is so prevalent that Android, built way before the introduction of Linux Kernel namespaces,² had to achieve basic file-system separation between apps by giving each package a distinct Linux _user_ ID at install time.³

Similar to the massively-succesful mobile model, and like the current efforts of macOS,⁴ the Linux desktop is migrating to a sandboxed model of security.⁵ PulseAudio, a core infrastructure layer of the Linux desktop, should be ready.

## The Problem
PulseAudio, being written in the Wintel era of computing,⁶ _heavily follows_ the user-centric model of security. It has usually evaded the security question, almost in entirety, by confining itself to run under user context. 

In the current model, applications can do whatever they like to the state of user's sound. An application can do any of the following:

##### Snoop on other application's audio
An application can access the final mixed audio of all other applications, sent to any sink, through the use of monitors:

```$ parec --file-format=wav -d $(pactl list sinks | grep Name | cut -d: -f2 | head).monitor snooped-audio.wav```

##### Have unmediated access to the micophone
Any application can access and access from the microphone. This means that a single browser or internet-facing-application exploit can lead to full audio data access. The simple recording command below can run from the context of any application:

```
$ parec --file-format=wav -d $(pactl list sources | grep Name | grep -v '\.monitor' | cut -d: -f2 | head) microphone-audio.wav
```

##### Control system objects outside of the application domain
Any application can induce system-wide effects regarding user audio. For example, an application can _suspend_ the main sink and the user won't hear audio from _any_ application:

```
$ pactl suspend-sink $(pactl list sinks | grep Name | cut -d: -f2 | head) 1
```

##### Load and unload server modules, including network ones
Any application can load or unload server modules, with parameters that might drastically increase the server's attack vector by listening to more network cards, protocols, and ports. An example of this case can be:

```
$ pactl load-module module-native-protocol-tcp listen=0.0.0.0 port=1234
```

##### Induce the server to get _reliably_ killed
Due to how PulseAudio is currently designed, certain workloads asked by the application can reliably kill the daemon by making it exceed its allocated real-time budget.⁷ ⁸ Typically speaking rtkit limits pulse real-time budget to 200ms – not to cause any havoc in the system if any pulse code goes awry.

For example, the following script will reliably kill the pulse server on a dual-core 3GHz x86 machine:

    #!/bin/bash

    wget -nc https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/WhiteNoise.flac

    for i in {1..60}; do
        echo "Client #$i";
        pacat --latency-msec=5000 --rate=384000 WhiteNoise.flac &
        sleep 1
    done

Moreover, [this malicious client](https://github.com/a-darwish/malicious-pulseaudio-clients/blob/master/kill_server_quickly_open_write_streams.c) will _instantaneously_ kill the server. It simply does so by quickly opening and writing to multiple connected streams.

##### Forbid other applications from using a sink
To protect resources, pulse has a hard-coded limit of 256 open streams (sink-inputs) per sink. If a malicious, or buggy, application makes the server reach that limit for the default sink, _no other application in the system_ will be able to output any audio.

In the early days, this limit was set to 32 streams. It was increased later to 256 stream due to web browsers, and as a result HTML5 games, becoming PulseAudio-native.⁹

For example, [this second malicious client](https://github.com/a-darwish/malicious-pulseaudio-clients/blob/master/exhaust_open_streams.c) will force-mute the system, without any ability to unmute it back except by killing the client or restarting the server. It does so by exhausting the number of open streams connected to the default sink, thus disabling any newly-connected app from outputting audio.

###### Reserve access to passthrough mode
to-be-filled.

###### Snoop on the server's global mempool
In PulseAudio, shared memory is used for audio transfers between the client and the server. For playback, a shared memory pool is created by the client to share the audio with the server. For recording, a _global_ shared pool used to share the audio with _all_ interested clients. This shared-memory mechanism is used to achieve low-latency and a single-copy sound architecture.

Classically, there are two _global_ shared memory pools created by the server:

- The shared-ringbuffer memory pool, created for [low-latency srbchannel command exchange mechanism](http://voices.canonical.com/david.henningsson/2014/11/21/pulseaudio-buffers-and-protocol/).
- The global mempool, created by the server to send recorded audio to interested clients in an efficient manner.

All clients have full read-access to these pools and thus any client _can snoop on their contents_. Since PulseAudio v9.0, the srbchannel mempool has been redesigned to get instantiated on a per-client basis, thus forbidding cross-application data leaks.¹⁰

We need to do the same for the global mempool and instantiate it on a per-client basis. Otherwise, any app can read the microphone's audio stream by snooping on that global pool. Since an attacker can achieve this through simple memory reads, this snooping can happen _even if an access-control layer was merged in PulseAudio_ to allow/deny access to the microphone. Due to the system's current design & codebase, a large patchset is needed for this transformation.¹¹

## Proposed Designs


## References & Footnotes
-  ¹ [An Experimental Time-Sharing System](https://raw.githubusercontent.com/a-darwish/cuteOS-references/master/papers/sched/Corbato62%20-%20An%20Experimental%20Time-Sharing%20System%20(Original).pdf), F.J. Corbato et al.
-  ² [Namespaces in Operation, part 1: Namespaces overview](https://lwn.net/Articles/531114/). Michael Kerrisk
-  ³ [Introduction: System Permissions](https://developer.android.com/guide/topics/security/permissions.html). Anrdroid Developers Guide
-  ⁴ [macOS App Sandboxing](https://developer.apple.com/app-sandboxing/), Apple Developers Guide
-  ⁵ As originally started by [GNOME's xdg-app effort](https://web.archive.org/web/20150128224610/https://wiki.gnome.org/Projects/SandboxedApps), and later renamed to [Flatpak](http://flatpak.org/)
-  ⁶ [The PulseAudio Sound Server](http://darwish.chasingpointers.com/pub/The%20PulseAudoi%20Sound%20Server%20-%20Lennart%202007.pdf), FOSS.in 2007, Lennart Poettering
-  ⁷ [PulseAudio gets reliably killed upon a big number of client connections](https://bugs.freedesktop.org/show_bug.cgi?id=94629). PulseAudio bugzilla
-  ⁸ [Timing issues in desktop audio playback infrastructure](http://lac.linuxaudio.org/2015/download/rewind-slides.pdf), Linux Audio Conference 2015, Alexander Patrakov
-  ⁹ [sink: Increase max sink inputs per sink](https://cgit.freedesktop.org/pulseaudio/pulseaudio/commit/?id=26bf2df903b1c7439ad3eef0dc3bb1e777835cc3), PulseAudio git log, Arun Raghavan
- ¹⁰ [pulsecore: Reference-count mempools](https://cgit.freedesktop.org/pulseaudio/pulseaudio/commit/?id=9bda6e344a67a9df245bd679706c9a0291b30d08), [srbchannel: Introduce per-client SHM files](https://cgit.freedesktop.org/pulseaudio/pulseaudio/commit/?id=211a520543b97c2c769d85bdc4d4c8d3a9023199), PulseAudio git log, Ahmed Darwish
- ¹¹ [On why the global mempool is not yet instantiated per-client](http://article.gmane.org/gmane.comp.audio.pulseaudio.general/25156). PulseAudio mailing list, Ahmed Darwish

⁰¹²³⁴⁵⁶⁷⁸⁹
