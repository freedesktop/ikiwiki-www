'''This is an RFC and does not necessarily represent the final implementation'''
----

= Goal =

Get all the passthrough support to the point where things work automagically
or with minimal user input, for AC3/DTS over S/PDIF or MP3 over Bluetooth. This
develops on Pierre-Louis Bossart's patches on the mailing list and subsequent
discussion between Pierre and Tanu Kaskinen.


= Broad idea =

When a client creates a new stream, it gives a list of formats that it can
provide. The list must cover all formats that the client can support (usually
the list contains only one tuple with only fixed parameters). The daemon routes
the stream to some sink, and then the daemon takes an intersection of the sink
formats and the stream formats.

If the resulting set contains exactly one fixed format, then that is
used for the stream. If the set contains more options than one fixed
format, then the daemon decides the "best" format using some unspecified
algorithm. If the set is empty, then the stream creation fails (do we want to
retry here?).

In the future, we can make it so that the API stops at an intermediate ROUTED
state if the client does not provide any formats. The client can then query
what formats are available and set the one it prefers.

If the user switches to a different sink, one of 3 scenarios can occur:

 a. Switch from PCM to compressed format: e.g. a switch to BT headset
 b. Switch from compressed to PCM format e.g. switch back to sound card
 c. Stay on PCM format

Switching from one compressed format to another (e.g. MP3 -> AC3) does not
make sense, so need not be supported. It is assumed that all sinks support
playing some PCM format (and that PA will convert as appropriate).

When switching to a new format, the client must close its current stream and
open a fresh stream in order to set things up for the new format.


= API changes =

== Formats ==

We add a new enum type to represent various encoding formats. For now, we do
not worry about VBR streams since all the use cases we're working with are
IEC61937 formatted and have a fixed bytes-to-us conversion. The formats we add
for now are: 

{{{
typedef enum pa_encoding_t {
    PA_ENCODING_PCM,
    PA_ENCODING_AC3_IEC61937,
    PA_ENCODING_EAC3_IEC61937,
    PA_ENCODING_DTS_IEC61937,
    PA_ENCODING_MPEG1_L3_IEC61937,
    PA_ENCODING_MPEG2_L3_IEC61937,
} pa_encoding_t;
}}}

This isn't exhaustive, and more formats can be added as they are actually
tested.

{{{
typedef struct pa_format_info {
    pa_encoding_t encoding;
    pa_proplist   *plist;
    /* `-- allow attaching arbitrary info, such as a priority, bitrate, ... */
} pa_format_info; 
}}}


== Stream API ==

The stream API gets an alternative version that uses pa_format_info instead
of pa_sample_spec:

{{{
/* format is an array of formats the client can offer */
pa_stream* pa_stream_new_extended(pa_context     *context,
	                	  const char     *name,
	                	  pa_format_info *format,
                                  pa_channel_map *map);

pa_stream* pa_stream_new_with_proplist_extended(pa_context     *context,
		                	        const char     *name,
		                	        pa_format_info *format,
	                                        pa_channel_map *map,
	                                        pa_proplist    *plist);
}}}

When making the connection, routing is performed and the selected format is returned as an out parameter.

{{{
int pa_stream_connect_playback_extended(pa_stream            *s,
				        const char           *dev,
				        const pa_buffer_attr *attr,
				        pa_stream_flags_t     flags,
				        const pa_cvolume     *volume,
				        pa_stream            *sync_stream,
				        const pa_format_info *final_format);
}
{{{
/* This is implicit in the format, but still convenient to have, and
 * effectively deprecates the PA_SINK_INPUT_PASSTHROUGH flag */
const pa_bool_t pa_encoding_is_passthrough(pa_encoding_t enc);
}}}
== Others ==

We need to make a volume/mute disabled notification for sinks and sink inputs
when they are operating in passthrough mode. Probably also best to disable the
monitor, but an override might be useful for debugging purposes.

For S/PDIF (and HDMI?) we should add a way for users to check off the formats
supported by their hardware in the UI (and probably attach this to the sink as
a property). The sink query can then use this to determine the list of
supported formats. For Bluetooth sinks, we can get this data from A2DP
capabilities, so no user intervention is required.

= Credit =

This RFC is based on Pierre's previous work and discussion on-/off-list with:

 * Pierre-Louis Bossart
 * Tanu Kaskinen
 * Wim Taymans
 * Arun Raghavan
