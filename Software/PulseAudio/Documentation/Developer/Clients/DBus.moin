This page should eventually contain the final D-Bus control interface specification.

Disclaimer: I'm not a D-Bus expert yet. The following text may include misconceptions.

== Proposal ==

If I don't get any opposition, I will aim to the following (names are preliminary, not much thought has been gone into deciding them):

''Per-user mode:''

 * When pulseaudio starts, it connects to the session bus and reserves name org.pulseaudio.Server.
   - If there is no session bus, tough luck - the D-Bus module fails to load.
     * What does this mean for console, SSH and cron users?
 * When a client wants to use the service, it calls org.freedesktop.DBus.!StartServiceByName on session bus.
   - If it succeeds, the client calls org.pulseaudio.Server.Ref
     * This is analogous to reference counting. When there are no references, the server may autoexit. Calling .Unref decrements the reference counter; disconnecting from the bus does the same thing, if .Unref hasn't been called.
 * If .!StartSerciveByName actually needs to start the service, it is done via a helper program, "pulse-dbus-helper".
   - pulse-dbus-helper checks if there already is a pulseaudio server running (in which case the server is connected to some other bus than the current session bus).
     * If there is, pulse-dbus-helper reads ~/.pulse/dbus-session-buses-in-use, which contains the list of the session buses (as newline-separated socket names) that the D-Bus module is already connected to. pulse-dbus-helper takes the first and connects to that bus, and calls org.pulseaudio.Server.!ConnectToAnotherBus, giving the current session bus socket name as a parameter. The server connects to the current session bus.
       - If the file is non-existent or empty, or contains bogus data, service starting fails.
     * If there isn't, pulse-dbus-helper starts the server.

''System-wide mode:''

 * When pulseaudio starts, it connects to the system bus and reserves name org.pulseaudio.Server.
 * When a client wants to use the service, it tries to start the service in the session bus first. That fails, so next the client checks if org.pulseaudio.Server exists in the system bus. It does, because when in system-wide mode, the server is started at boot and it doesn't autoexit. (Is this a bad assumption?)
 * Clients have permission to use the service, if they belong to the right group.

''Remote access:''

 * When pulseaudio starts, it launches a custom tcp bus and reserves name org.pulseaudio.Server.
 * When a client wants to use the service, it just connects to the right bus. How this is configured is left to each individual client program.
   - This might be a bad idea. Maybe we should extend the server string spec to include D-Bus services - those could be prefixed with "dbus:". The clients would of course now need to parse environment variables and client.conf. Maybe a helper script would be appropriate that would just print out the bus address based on the environment variables and client.conf?
 * If pulseaudio autoexits, the custom bus shuts down too, because the only alternative to this, what I'm able to come up with, is to leave the bus running indefinitely.
 * Because of the previous point, there's no need to call org.freedesktop.DBus.!StartServiceByName, but calling it doesn't hurt.
 * Authentication is done by calling org.pulseaudio.Server.Authenticate with the pulseaudio cookie as a parameter.
   - The bus has to be configured to disallow eavesdropping.
   - The TCP stream usually isn't encrypted, so sniffing the cookie at an intermediary machine is possible. (AFAIK this isn't a regression?)
   - Remote connections can't be limited by IP address. This is a regression.
 * After authentication, .Ref and .Unref need to be used to handle autoexiting properly.
