== Desktop VFS ==

Desktop VFS aims to provide a system allowing desktop-oriented applications, such as file managers and office applications among others, to have access to remote data storage facilities using a Virtual File System API.

D-VFS is not oriented towards general purpose usage.  The design goal is specifically desktop applications and their needs.  The project is not an attempt to build a low-level system-wide VFS (see [http://fuse.sourceforge.net FUSE]) but instead is an attempt to establish an API based on the operations desktop application wish to perform.  For example, instead of building on the POSIX API, the D-VFS API will be based on operations like "save whole document," "read whole document," "list files in folder," and so on.

D-VFS is in the first stages of design. The requirements and api are being fleshed out at this location.  Adding your comments to the design of D-VFS is very simple.  First, get a freedesktop [Login login].  Second, edit this page by hitting the [[Icon(edit)]] icon.  Once you have edited this page, you will be signed up for email notifications of any future edits on this page.

== Design ==

Desktop VFS is intended to be used primarily by desktop apps like office suites and by desktop file managers like Nautilus or Konquerer.  These applications have a certain set of operations which they must perform in order to operate correctly.

 * Save and load documents
 * Manipulate document metadata
 * List files in a folder
 * Move, copy, and delete documents
 * Create, move, copy, and delete folders

Additionally, desktop application have certain requirements in terms of implementation details and API features.

 * Event-based (asynchronous) API
 * Complete error reporting with user-oriented messages available
 * Monitor progress of any operation
 * Cancel any in-progress operation
 * Resume operations with non-critical errors ("failed to make backup; save anyhow?")
 * Threads
 * Change notification for folders and documents

Finally, the design should provide certain features and benefits that, while not being critical to basic operation, will increase the viability of using the system and the ease of developing against the system.

 * Push/pull (synchronous) API
 * Ability to implement a POSIX-ish layer on top of the VFS for legacy-app support and quick-n-dirty porting
 * Extensible API that makes adding new features and capabilities very easy without breaking compatibility (in either direction)
 * Easy to use API that makes development of secure and stable VFS usage very simple

== Rationalization ==

Simply stating that we have certain goals is useless without explaining why we have certain goals.

=== Save and Load Interface ===

Traditional file APIs, such as POSIX, are based on a concept of reading and writing bytes.  When you develop an application that reads a file with these APIs, your application is not truly written around the concept of reading the file; instead, it's written around the concept of reading chunks of bytes.  The same goes for writing files.  Additionally, these interfaces are very complex to use.  Operations can be interrupted in the middle of their work, resulting in syscalls that can do only half of what you asked them to do.  The random-access nature of the file system also results in a lot of complication in the entire design of the system.

While these APIs are very useful to certain classes of applications - database apps, for example - they are often far more complicated and detailed than your average desktop application needs.  A desktop application saves and loads files.  That is pretty much it.  Your word processor loads a document, then saves it.  Your text editor does the same.  Your email client might save copies of message or attachments.  Your web browser saves downloads.  These types of applications save and load whole files as their basic file-level operation.  Making these two operations as easy and efficient as possible will result in an API that is ideal for desktop-appliaction usage.

It is noted that desktop apps often do access files besides the user's documents.  Your word processor might save configuration files, for example, or a recently-used files list, and so on.  The Desktop VFS is ''not'' designed for these files.  Those files are typically stored in the user's home folder in a dot-directory.  That is a local file system.  Applications can, and absolutely should, use the system's native file API (POSIX) for these files.

=== Folder Management ===

Even a basic desktop application needs support for basic folder handling.  For example, the open document or save document interfaces in the application need to be able to let the user select a folder for the document.  Users usually want to be able to use a graphical file manager as well, which also requires support for managing folders.

Folder operations are relatively simple in definition, but can be very complex in implementation.  The POSIX API is almost useless for manipulating folders.  The most basic of command-line tools, such as rm, ls, cp, and mv, spend a disproportional amount of code dealing with the ineffectiveness of the POSIX APIs for dealing with folders.

POSIX cannot delete a folder unless you empty it first.  POSIX cannot move a folder (or a file) across file-system boundaries, which under the UNIX system are difficult to even know exist (/home/user/docs can be on a different file-system than /home/user/code, for example).  Basic operations that a user or file manager would want to perform, such as "copy folder," require a very large amount of work.

D-VFS will simplify this.  The API will provide functinos for "move folder" and similar operations.  As with all other operations, these will be asynchronous, provide progress feedback, be cancelable, and hide implementation details.

=== Change Notification ===

Change notification is primarily useful to file managers.  A file manager displaying a folder might want to automatically update the display if the user saves or deletes a document from within that folder using a different application, for example.

Change notification is slightly complex due to the fact that most interesting protocols that will be in use with D-VFS do not actually support change notification.  This will result in one of two scenarios: either those protocols will simply not support change notification at all, or a polling method will be put in place so that change notification is transparently supported.

If change notification is simply left unsupported on most protocols, it is reasonable to expect that applications themselvs may resort to implementing their own polling method.  It is not optimal to have this code duplicated between multiple projects.  It therefor makes sense to offer a built-in polling solution that can be used with all protocols that do not have built-in change notification support.

Change notification works by registering a URI to receive notifications, and potentially the types of events that the application is interested in.

TODO: go into more depth here, change notification is kind of a complex beast.

=== POSIX Compatibility ===

Being POSIX compatible is not a goal of the core API at all.  In fact, one of the driving forces behind this project is that the POSIX API is inadequate in far too many ways.

However, it should be possible to build a POSIX API on top of D-VFS.  Some of the operations may not have perfectly clean mappings to POSIX, and many of the details may be incompatible with a strict interpretation of the POSIX specification, but in general such a mapping will work "well enough."

Providing this POSIX layer is not a goal of D-VFS, and any such efforts will likely occur outside the D-VFS project itself.  One of the more promising uses of such a layer would be in [http://fuse.sourceforge.net FUSE], a user-space file-system layer for the Linux kernel.

=== Event Based API ===

A GUI application is expected to remain responsive to user and system events.  If a GUI application blocked on a syscall like stat(), it would no longer be able to respond to user input events, X expose events, and so on.  Some apps also have constant work to do perform (such as animations or other processing) that must continue even while VFS operations are being performed.

An event-based API allows these applications to function as expected.  The application tells teh VFS to begin an operation, and gets a handle refering to that operation.  The VFS system then sends progress update events to the application, which can be used for GUI progress meters.  The handle can be used to cancel the operation (perhaps on user request).

=== Push/Pull API ===

While the event-based API makes it easiest to build responsive, dynamic applications, an event-based API is simply harder to use that traditional file-access APIs.  An event-based API requests event handlers, callbacks, state tracking, and so on; in most popular programming languages (including C and C++) coding against such an API can be difficult.

A push/pull API works differently.  The application initiates an operation and waits until its complete.  It decides when to push and pull data during a file read or save instead of having the VFS tell the application what to do with callbacks.  GUI apps can still use such a model in a way very similar to how they handle modal dialogs.  The biggest problem is that such code likely *would* be "modal" in nature, or require a more complex application in areas other than the VFS.

However, there are enough applications that would work fine with a push/pull API, and the difference in ease of development against such an API is large enough, that providing this API is worth-while.

== VFS Daemon ==

The VFS daemon will be a per-user process that is initiated during login, or on demand if not already running.  The daemon is responsible for doing the meat of all the VSF work.

=== Advantages ===

The easiest and more obvious way to implement a protocol in the D-VFS library is to simply provide a shared library loaded at runtime which interacts with the protocol directly.  For example, if an app wants to access an SMB share, the application process itself would run that code that connected to the share, authenticated the user, and performed the operations.

This implementation has several disadvantages.  First, for certain protocols such as FTP, connection sharing is fairly important.  FTP servers usually have a limit on the number of connections they support.  If a user has an FTP folder open in their file manager, and then wants to load a file in their word processor, and the FTP server supports only a single connection from a given user/IP, the word processor could not open the document until the user closes the file manager.  This situation is not acceptable.  By using a daemon, the file manager and word processor would marshal all operations through the daemon and that daemon can support both applications using only  a single connection to the FTP server.

The second disadvantage of not using a daemon is the protection of user passwords.  If each application must have access to the user's password, that makes it very easy for a malicious piece of software or a virus to read the user's stored passwords or snoop the password as the user enters it.  With a daemon, the system can be configured in such a fashion that only the daemon can access the user's passwords, and that the daemon alone (or a helper process) asks the user for authentication.  This ensures that any random app can't just read the user's passwords, and makes it possible for systems with secure X extensions to ensure that apps can't spoof the authentication dialog and steal the user's passwords.

The third advantage of a daemon is also related to security.  A well secured system will heavily restrict many apps.  This is especially true on systems using SELinux (or the equivalents on the target operating system).  The system might be configured such that the word processor can only access documents in the user's home folder and that it can't connect to the network.  (That way a virus could not infect the word processor or its macros and try to download a rootkit or something like that.)  However, this lockdown would make it impossible for D-VFS to operate if the word processor itself performed the network operations.  By using a daemon, the security contexts can be configured such that the daemon can access the network (and even then it can be restricted to which networks and protocols it can use, and which applications can connect to the daemon) resulting an overall more secure system that is still usefully functional.  Making D-VFS with technologies like SELinux is very important to the future of the system, as these technologies are expected to be major backbones of the UNIX security model in the future.

The fourth advantage of the daemon is that it makes it much easier to handling threading, as you don't have to worry about how threads will interact with the client application.  Threading will likely be required for certain protocols, such as handling file: (slow NFS shares) or SMB (as the libsmbclient API is braindead).

A final broad advantage of a daemon is that certain features, such as change notification polling, become a lot easier when they're done in a separate process from the application itself.

=== Disadvantages ===

The main disadvantage of using a daemon is the potential speed degradation.  Two processes become involved in every operation, including transfer of data.  However, fast file operation is not very important for the D-VFS use case.  The target apps of D-VFS are far more concerned with perceived speed increases, such as those obtained with asynchronous folder listings, than they are with raw throughput or latency.  Even then, the actual degredation in throughput and latency should be well within acceptable margins, to the point of being unnoticable by users.

The daemon will be a required part of the implementation.  While it might seem advantageous to make the daemon optional, due to the requirement of threads for certain protocols, it would be overly complicated to make the API cleanly and easily handle backends run in-process.

=== Protocol Backends ===

The system will be comprised of backends which implement protocols.  A single backend may support more than one protocol.  For example, a neon backend might support both dav: and davs:, while an SFTP backend might also implement support for SCP.  It's possible that more than one backend might be installed that implements a particular protocol.

The backends will provide a list of capabilities and entry points for using the backend.  A very simple model would simply provide a vtable of function pointers.  Whether a particular entry is set or not would indicate whether the capability is supported and would also provide the entry point to the backend.  It's also possible to use a more complex query interface.  This is necessary for applications to potentially alter behavior based on which capabilities a backend has - a client that can handle versioned file systems would want to grey-out menu items for versioning on a file system that doesn't support that feature, for example.

The idea of using a vtable or query interface in the backends also helps ensure bidirectional interface stability.  For example, D-VFS 1.1 will have some additional features and entry points compared to D-VFS 1.0.  We want to ensure that a backend developed against 1.0 is usable with 1.1, and that a backend developed with 1.1 is usable with 1.0.  An older backend used with a newer library will simply not provide implementations of the newer capabilities, but won't lose any functionality.  A newer backend used with an older library will simply support features that the library can't use, but that shouldn't stop the backend from providing the functionality that the older library does know about.

By doing this, we make it much, much easier for third party developers to build, distribute, and support custom protocol backends.  This can be especially important for in-house development projects with oddball specialized protocols that need to be usable on a variety of machines in the organization.

=== Threading ===

Threading in the daemon will be required for several protocols, such as file: or smb:, due to either limitations in the syscall interface or due to bad library API.  While I (SeanMiddleditch) was originally opposed to threading, it does seem to be a necessary evil.  Given that I hadn't previously put much thought into the threading model, input on the best model to use here would be useful.  I'm thinking that the daemon can start a thread for each session (ie connection) if the backend says that it is needed.  The daemon core should handle the threading to avoid duplicating that effort in each backend.

(AlexanderLarsson) On the client side, the library needs to be threadsafe. We've had problems in gnome-vfs with apps like OOo using gnome-vfs async operations which weren't always threadsafe.

=== Authentication ===

The daemon will need to authenticate to most remote resources.  Authentication can take several forms, many of which require interaction with the user or an external authentication information store.

Existing VFS systems put the burden of retrieving authentication information to the application that initiates the request.  However, this has several drawbacks.  The first is that it requires that the application actually include a method for handling the authentication request.  The second is that it makes it impossible to limit which applications have access to your authentication information.  If you run an untrusted application, even in a secured context (like under SELinux), you would have to type your password into a dialog owned by that application, making it possible for the app to steal that key.

D-VFS should instead rely entirely on itself or a trusted helper process to do all user interaction for authentication.  Only these two trusted apps will ever access a user's passwords or other credentials.  This makes it far easier to lock down the system using SELinxu or TrustedBSD/Solaris, and can completely eliminate the possibility of a malicious or buggy application getting access to your authentication secrets.

The daemon will also be responsible for determing whether a particular application is allowed to access a given share.  In a locked-down system, an administrator might decide that all trusted app may ever access files on the company CIFS server, for example.  The daemon can use various means, including SELinux contexts, to enforce these policies.

== Licensing ==

This is always a scary subject to approach, but it's worth mentioning in brief even at this point.  The D-VFS is intended to be of maximum utility to both users and developers.  It is important that any potentially restrictive licensing problems be avoided to ensure that the system is used by the widest range of software projects possible.  Simply following suite with D-BUS' licensing or using the MIT license (like Xorg does) is probably the best bet all around.

== Discussion ==

The mailing list threads which recently started this discussion are:
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002322.html A virtual filesystem standard]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002340.html A virtual filesystem standard]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002398.html virtual filesystem ideas]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002400.html virtual filesystem ideas]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002406.html a common VFS - a different approach]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002423.html virtual filesystem ideas]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002425.html VFS ramblings]
 * [http://lists.freedesktop.org/archives/xdg/2003-September/002434.html Fwd: Re: virtual filesystem ideas]
 * [http://lists.freedesktop.org/archives/xdg/2005-February/005946.html A common VFS and a Common conf-system (Was: namespacing)]
 * [http://lists.freedesktop.org/archives/xdg/2005-March/005957.html A common VFS and a Common conf-system [Part II]]
 * [http://lists.freedesktop.org/archives/xdg/2005-March/005958.html A common VFS and a Common conf-system (Was: namespacing)]
 * [http://lists.freedesktop.org/archives/xdg/2005-March/005968.html A common VFS and a Common conf-system (Was: namespacing)]
 * [http://lists.freedesktop.org/archives/xdg/2005-March/005972.html A common VFS and a Common conf-system (Was: namespacing)]


 * [http://live.gnome.org/GnomeVfsPlans The Gnome wiki for VFS]

Please append your comments here:

(GeorgeStaikos) How do you plan to deal with complex issues like HTTP, where "sessions" are required with multiple concurrent slaves running?  It also requires huge amounts of callbacks, user interaction, system-wide SSL integration, and much much more.  Making this portable across desktops is painful at best, if sane.

=== Mailinglist ===

All previous D-VFS discussion has been on [http://lists.freedesktop.org/mailman/listinfo/xdg the main xdg mailing list].  Please add specific vfs requirements or proposals on this Wiki.  Discussion of more general interest should continue to be posted on [http://lists.freedesktop.org/mailman/listinfo/xdg xdg]


=== CVS ===

There is no CVS repository as there is no api or documentation.


=== Bugs & Patches ===

There is no Bugzilla as there is no api or documentation.


== Download ==

There are no downloads as there is no api, implementation, tests, samples, or documentation.
