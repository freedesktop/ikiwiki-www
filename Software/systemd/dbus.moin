[[http://www.freedesktop.org/wiki/Software/systemd/|Back to systemd]]

= The D-Bus API of systemd/PID 1 =

systemd and its auxiliary daemons expose a number of APIs on D-Bus. The following describes the various APIs exposed by the system and service manager itself, and does not cover the auxiliary daemons.


== The Manager Object ==
{{{
$ gdbus introspect --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1
node /org/freedesktop/systemd1 {
  interface org.freedesktop.systemd1.Manager {
    methods:
      GetUnit(in  s name,
              out o unit);
      GetUnitByPID(in  u pid,
                   out o unit);
      LoadUnit(in  s name,
               out o unit);
      StartUnit(in  s name,
                in  s mode,
                out o job);
      StartUnitReplace(in  s old_unit,
                       in  s new_unit,
                       in  s mode,
                       out o job);
      StopUnit(in  s name,
               in  s mode,
               out o job);
      ReloadUnit(in  s name,
                 in  s mode,
                 out o job);
      RestartUnit(in  s name,
                  in  s mode,
                  out o job);
      TryRestartUnit(in  s name,
                     in  s mode,
                     out o job);
      ReloadOrRestartUnit(in  s name,
                          in  s mode,
                          out o job);
      ReloadOrTryRestartUnit(in  s name,
                             in  s mode,
                             out o job);
      KillUnit(in  s name,
               in  s who,
               in  i signal);
      ResetFailedUnit(in  s name);
      GetJob(in  u id,
             out o job);
      ClearJobs();
      ResetFailed();
      ListUnits(out a(ssssssouso) units);
      ListJobs(out a(usssoo) jobs);
      Subscribe();
      Unsubscribe();
      CreateSnapshot(in  s name,
                     in  b cleanup,
                     out o unit);
      Reload();
      Reexecute();
      Exit();
      Reboot();
      PowerOff();
      Halt();
      KExec();
      SwitchRoot(in  s new_root,
                 in  s init);
      SetEnvironment(in  as names);
      UnsetEnvironment(in  as names);
      UnsetAndSetEnvironment(in  as unset,
                             in  as set);
      ListUnitFiles(out a(ss) changes);
      GetUnitFileState(in  s file,
                       out s state);
      EnableUnitFiles(in  as files,
                      in  b runtime,
                      in  b force,
                      out b carries_install_info,
                      out a(sss) changes);
      DisableUnitFiles(in  as files,
                       in  b runtime,
                       out a(sss) changes);
      ReenableUnitFiles(in  as files,
                        in  b runtime,
                        in  b force,
                        out b carries_install_info,
                        out a(sss) changes);
      LinkUnitFiles(in  as files,
                    in  b runtime,
                    in  b force,
                    out a(sss) changes);
      PresetUnitFiles(in  as files,
                      in  b runtime,
                      in  b force,
                      out b carries_install_info,
                      out a(sss) changes);
      MaskUnitFiles(in  as files,
                    in  b runtime,
                    in  b force,
                    out a(sss) changes);
      UnmaskUnitFiles(in  as files,
                      in  b runtime,
                      out a(sss) changes);
    signals:
      UnitNew(s id,
              o unit);
      UnitRemoved(s id,
                  o unit);
      JobNew(u id,
             o job,
             s unit);
      JobRemoved(u id,
                 o job,
                 s unit,
                 s result);
      StartupFinished(t kernel,
                      t initrd,
                      t userspace,
                      t total);
      UnitFilesChanged();
    properties:
      readonly s Version = 'systemd 185';
      readonly s Distribution = 'fedora';
      readonly s Features = '+PAM +LIBWRAP +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP';
      readonly s Tainted = '';
      readonly t InitRDTimestamp = 1340822954724393;
      readonly t InitRDTimestampMonotonic = 2431571;
      readonly t StartupTimestamp = 1340822956472674;
      readonly t StartupTimestampMonotonic = 4179853;
      readonly t FinishTimestamp = 1340822966825952;
      readonly t FinishTimestampMonotonic = 14533131;
      readwrite s LogLevel = 'debug';
      readwrite s LogTarget = 'kmsg';
      readonly u NNames = 249;
      readonly u NJobs = 0;
      readonly u NInstalledJobs = 4;
      readonly u NFailedJobs = 0;
      readonly d Progress = 1.0;
      readonly as Environment = ['SYSFONT=latarcyrheb-sun16', 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin', 'DRACUT_QUIET=yes', 'LANG=en_US.UTF-8', 'KEYTABLE=de-latin1'];
      readonly b ConfirmSpawn = false;
      readonly b ShowStatus = true;
      readonly as UnitPath = ['/etc/systemd/system', '/run/systemd/generator', '/usr/lib/systemd/system'];
      readonly s ControlGroupHierarchy = '/system';
      readonly as DefaultControllers = ['cpu'];
      readonly s DefaultStandardOutput = 'journal';
      readonly s DefaultStandardError = 'inherit';
      readwrite s RuntimeWatchdogUSec = 0;
      readwrite s ShutdownWatchdogUSec = 600000000;
  };
  interface org.freedesktop.DBus.Properties {
  };
  interface org.freedesktop.DBus.Peer {
  };
  interface org.freedesktop.DBus.Introspectable {
  };
};
}}}

=== Security ===

Read access is generally granted to all clients, but changes may only be made by privileged clients. !PolicyKit is not used by this service, and access controlled exclusively via the D-Bus policy enforcement.

=== Methods ===

Note that many of the calls exists twice: once on the Manager object, and once on the respective unit objects. This is to optimize access times so that methods that belong to unit objects do not have to be called with a resolved unit path, but can be called with only the unit id, too.

'''!GetUnit()''' may be used to the the unit object path for a unit name. It takes the unit name and returns the object path. If a unit has not been loaded yet by this name this call will fail.

'''GetUnitByPID()''' may be used to get the unit object path of the unit a process ID belongs to. Takes a Unix PID and returns the object path. The PID must refer to an existing process of the system.

'''!LoadUnit()''' is similar to !GetUnit() but will load the unit from disk if possible.

'''!StartUnit()''' enqeues a start job, and possibly a depending jobs. Takes the unit to activate, plus a mode string. The mode needs to be one of replace, fail, isolate, ignore-dependencies, ignore-requirements. If "replace" the call will start the unit and its dependencies, possibly replacing already queued jobs that conflict with this. If "fail" the call with start the unit and its dependencies, but will fail if this would change an already queued job. if "isolate" the call will start the unit in question and terminate all units that aren't dependencies of it. If "ignore-dependencies" will start a unit but ignore all its dependencies. If "ignore-requirements" will start a unit but only ignore the requirement dependencies. It is not recommended to make use of the latter two options. Returns the newly created job object.

'''!StartUnitReplace()''' is similar to '''!StartUnit()''' but replaces a job that is queued for one unit by a job for another.

'''!StopUnit()''' is similar to '''!StartUnit()''' but stops the specified unit rather than starting it. Note that "isolate" mode is invalid for this call.

'''!ReloadUnit()''', '''!RestartUnit()''', '''!TryRestartUnit()''', '''!ReloadOrRestartUnit()''', '''!ReloadOrTryRestartUnit()''' may be used to restart and/or reload a unit, and takes similar arguments as '''!StartUnit()'''. Reloading is done only if the unit is already running and fails otherwise. If a service is restarted that isn't running it will be started, unless the "Try" flavour is used in which case a service that isn't running is not affected by the restart. The "!ReloadOrRestart" flavours attempt a reload if the unit supports it and use a restart otherwise.

'''!KillUnit()''' may be used to kill (i.e. send a signal to) all processes of a unit. Takes the unit name, an enums who and a UNIX signal number to send. The who enum is one of "main", "control" or "all". If "main", only the main process of a unit is killed. If "control" only the control process of the unit is killed, if "all" all processes are killed. A "control" process is for example a process that is configured via !ExecStop= and is spawned in parallel to the main daemon process, in order to shut it down.

'''!GetJob()''' returns the job object path for a specific job, identified by its id.

'''!ClearJobs()''' flushes the job queue, removing all jobs that are still queued. Note that this does not have any effect on jobs whose execution has already begun, it only flushes jobs that are queued and have not yet begun execution.

'''!ResetFailedUnit()''' resets the "failed" state of a specific unit.

'''!ResetFailed()''' resets the "failed" state of all units.

'''!ListUnits()''' returns an array with all currently loaded units. Note that units may be known by multiple names at the same name, and hence there might be more unit names loaded than actual units behind them. The array consists of structures with the following elements:

 * The primary unit name as string
 * The human readable description string
 * The load state (i.e. whether the unit file has been loaded successfully)
 * The active state (i.e. whether the unit is currently started or not)
 * The sub state (a more fine-grained version of the active state that is specific to the unit type, which the active state is not)
 * A unit that is being followed in its state by this unit, if there is any, otherwise the empty string.
 * The unit object path
 * If there is a job queued for the job unit the numeric job id, 0 otherwise
 * The job type as string
 * The job object path

'''!ListJobs()''' returns an array with all currently queued jobs. Returns an array consisting of structures with the following elements:

 * The numeric job id
 * The primary unit name for this job
 * The job type as string
 * The job state as string
 * The job object path
 * The unit object path

'''Subscribe()''' enables most bus signals to be sent out. Clients which are interested in signals need to call this function. Signals are only sent out if at least one client invoked this function. '''Unsubscribe()''' undoes the signal subscription that Subscribe() implements. It is not necessary to invoke Unsubscribe() as clients are tracked. Signals are no longer sent out as soon as all clients which previously asked for Subscribe() either closed the bus connection or invoked Unsubscribe().

'''!CreateSnapshot()''' creates a snapshot unit for the current system state, and stores it under the specified name. It will return the unit object path to the new snapshot. If the cleanup boolean is true the snapshot will be removed automatically when it has been activated, otherwise it remains and can be activated multiple times. Snapshots are not persistant.

'''Reload()''' may be invoked to reload all unit files.

'''Reexecute()''' may be invoked to reexecute the main manager process. It will serialize its state, reexecute, and deserizalize the state again. This is useful for upgrades and is a more comprehensive version of Reload(). 

'''Exit()''' may be invoked to ask the manager to exit. This is not available for the system manager and is useful only for user session managers.

'''Reboot()''', '''!PowerOff()''', '''Halt()''', '''KExec()''' may be used to ask for immediate reboot, powering down, halt or kexec based reboot of the system. Note that this does not shut down any services and immediately transitions into the reboot process. These functions are normally only called as last step of shutdown, and should not be called directly. To shut down the machine it is a much better choice generally to invoke Reboot() and !PoweOff() on the logind manager object. See [[http://www.freedesktop.org/wiki/Software/systemd/logind|On logind]] for more information.

'''!SwitchRoot()''' may be used to transition to a new root directory. This is intended to be used by initial RAM disks. The call takes two arguments: the new root directory (which needs to be specified), plus an init binary path (which may be left empty, in which case it is automatically searched for). The state of the system manager will be serialized before the transition. After the transition the manager binary on the main system is invoked and replaces the old PID 1. All state will then be deserialized.

'''!SetEnvironment()''' may be used to alter the environment block that is passed to all spawned processes. Takes a string array with environment variable assignments. Settings passed will override previously set variables.

'''!UnsetEnvironment()''' may be used to unset environment variables. Takes a string array with environment variable names. All variables specified will be unset (if they have been set previously) and no longer be passed to all spawned processes. This call has no effect for variables that were previously not set, but will not fail in that case.

'''!UnsetAndSetEnvironment()''' is a combination of !UnsetEnvironment() and !SetEnvironment(). It takes two lists. The first one is a list of variables to unset, the second one of assignments to set. If a variable is listed in both the variable is set after this call, i.e. the set list overrides the unset list.

'''!ListUnitFiles()''' returns an array of unit names plus their enablement status. Note that !ListUnit() returns a list of units currently loaded into memory, while !ListUnitFiles() returns a list of unit ''files'' that could be found on disk. Note that while most units are read directly from a unit file 
with the same name some units are not backed by files, and some files (templates) cannot directly be loaded as units but need to be instantiated.

'''!GetUnitFileState()''' returns the current enablement status of specific unit file.

'''!EnableUnitFiles()''' may be used to enable one or more units in the system (by creating symlinks to them in /etc or /run). It takes a list of unit files to enable (either just file names or full absolute paths if the unit files are residing outside the usual unit search paths), and two booleans: the first controls whether the unit shall be enabled for runtime only (true, /run), or persistently (false, /etc). The second one controls whether symlinks pointing to other units shall be replaced if necessary. This call returns one boolean and an array with the changes made. The boolean signals whether the unit files contained any enablement information (i.e. an [Install]) section. The changes list consists of structures with three strings: the type of the change (one of ''symlink'' or ''unlink''), the file name of the symlink and the destination of the symlink. Note that most of the following calls return a changes list in the same format.

Similar, '''!DisableUnitFiles()''' disables one or more units in the system, i.e. removes all symlinks to them in /etc and /run. 

Similar, '''!ReenableUnitFiles()''' applies the changes to one or more units that would result from disabling and enabling the unit quickly one after the other in an atomic fashion. This is useful to apply updated [Install] information contained in unit files.

Similar, '''!LinkUnitFiles()''' links unit files (that are located outside of the usual unit search paths) into the unit search path.

Similar, '''!PresetUnitFiles()''' enables/disables one ore more units file according to the preset policy. See [[http://freedesktop.org/wiki/Software/systemd/Preset|Presets]] for more information.

Similar, '''!MaskUnitFiles()''' masks unit files, and '''!UnmaskUnitFiles()''' unmasks them again.

=== Signals ===

Note that most signals are sent out only after '''Subscribe()''' has been invoked by at least one client. Make sure to invoke this call when subscribing to these signals!

'''!UnitNew()''' and '''!UnitRemoved()''' are sent out each time a new unit is loaded or unloaded. Note that this has little to do whether a unit is available on disk or not, and simply reflects the units that are currently loaded into memory. The signals take two parameters: the primary unit name and the object path.

'''!JobNew()''' and '''!JobRemoved()''' are sent out each time a new job is queued or dequeued. Both signals take the numeric job ID, the bus path and the primary unit name for this job as arguent. '''!JobRemoved()''' also includes a result string, being one of {{{done}}}, {{{canceled}}}, {{{timeout}}}, {{{failed}}}, {{{dependency}}}, {{{skipped}}}. {{{done}}} indicates successful execution of a job. {{{canceled}}} indicates that a job has been canceled (via !CancelJob() above) before it finished execution (this doesn't necessarily mean though that the job operation is actually cancelled too, see above). {{{timeout}}} indicates that the job timeout was reached. {{{failed}}} indicates that the job failed. {{{dependency}}} indicates that a job this job has been depending on failed and the job hence has been removed too. {{{skipped}}} indicates that a job was skipped because it didn't apply to the units current state.

'''!StartupFinished()''' is sent out when startup finished. It carries four usec timespan values each indicating how much boot time has been spent in the kernel, in the initrd, in userspace and in total. These values may also be calculated from the !InitRDTimestampMonotonic, !StartupTimestampMonotonic, !FinishTimestampMonotonic properties (see below).

'''!UnitFilesChanged()''' is sent out each time the list of enabled or masked unit files on disk have changed.

=== Properties ===

Most properties simply reflect the respective options in {{{/etc/systemd/system.conf}}} and the kernel command line. The others:

'''Version''' encodes the version string of the running systemd instance.

'''Distribution''' encodes for which distribution the running systemd instance has been compiled.

'''Features''' encodes the features that have been enabled resp. disabled for this build. Enabled options are prefixed with +, disabled options with -.

'''Tainted''' encodes a couple of taint flags, as colon seperated list. When systemd detects it is run on a system with certain problems it will set an appropriate taint flag. Taints may be used to lower the chance of bogus bug reports. The following taints are currently known: {{{split-usr}}}, {{{mtab-not-symlink}}}, {{{cgroups-missing}}}, {{{local-hwclock}}}. {{{split-usr}}} is set if /usr is not pre-mounted when systemd is first invoked. See [[http://freedesktop.org/wiki/Software/systemd/separate-usr-is-broken|Booting Without /usr is Broken]] for details why this is bad. {{{mtab-not-symlink}}} indicates that {{{/etc/mtab}}} is not a symlink to {{{/proc/self/mounts}}} as required. {{{cgroups-missing}}} indicates that control groups have not been enabled in the kernel. {{{local-hwclock}}} indicates that the local RTC is configured to be in local time rather than UTC. 

'''InitRDTimestamp''', '''InitRDTimestampMonotonic''', '''!StartupTimestamp''', '''!StartupTimestampMonotonic''', '''!FinishTimestamp''', '''!FinishTimestampMonotonic''' encode CLOCK_REALTIME resp. CLOCK_MONOTONIC usec timestamps taken when the initrd first began execution, when the main systemd instance began execution and finally, when all queued startup jobs finished execution. These values are useful for determining boot-time performance.

'''NNames''' encodes how many unit names are currently known. This only includes names of units that are currently loaded and can be more than actually loaded units since units may have more than one name.

'''NJobs''' encodes how many jobs are currently queued.

'''NInstalledJobs''' encodes how many jobs have ever been queued in total.

'''NFailedJobs''' encodes how many jobs have ever failed in total.

'''Progress''' encodes boot progress as floating point value between 0.0 and 1.0. This value begins at 0.0 at early-boot and ends at 1.0 when boot is finished and is based on the number of executed and queued jobs. After startup this field is always 1.0 indicating a finished boot.

'''Environment''' encodes the environment block passed to all executed services. It may be altered with bus calls such as !SetEnvironment() (see above).

'''!UnitPath''' encodes the currently active unit file search path. It is an array of strings, each being one file system path.

'''!ControlGroupHierarchy''' encodes the control group root path for this systemd instance. Prefixing {{{/sys/fs/cgroup/}}} turns this into a file system path.

== Job Objects ==
{{{
}}}

== Service Unit Objects ==

{{{
}}}

== Socket Unit Objects ==
{{{
}}}

== Device Unit Objects ==
{{{
}}}

== Mount Unit Objects ==
{{{
}}}

== Automount Unit Objects ==
{{{
}}}

== Snapshot Unit Objects ==
{{{
}}}

== Timer Unit Objects ==
{{{
}}}

== Swap Unit Objects ==
{{{
}}}

== Path Unit Objects ==
{{{
}}}
