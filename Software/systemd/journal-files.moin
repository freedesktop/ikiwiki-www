[[http://www.freedesktop.org/wiki/Software/systemd/|Back to systemd]]

= Journal File Format =

The systemd journal stores log data in a binary format with several features:

 * Fully indexed by all fields
 * Can store binary data, up to 2^64-1 in size
 * Seekable
 * Primarily append-based, hence robust to corruption
 * Support for in-line compression
 * Support for in-line Forward Secure Sealing

This document explains the basic structure of the file format on disk. We are making this available primarily to allow review and provide documentation. Note that the actual implementation in the [[http://cgit.freedesktop.org/systemd/systemd/tree/src/journal|systemd codebase]] is the only ultimately authoritative description of the format, so if this documentation and the code disagree, the code is right. That said we'll of course try hard to keep this documentation up-to-date and accurate.

Instead of implementing your own reader or writer for journal files we ask you to use the [[http://www.freedesktop.org/software/systemd/man/sd-journal.html|Journal's native C API]] to access these files. It provides you with full access to the files, without limitations, and will not withhold any data. If you find a limitation, please ping us and we might add some additional interfaces for you.

If you need access to the raw journal data in serialized stream form without C API our recommendation is to make use of the [[http://www.freedesktop.org/wiki/Software/systemd/export|Journal Export Format]], which you can get via "journalctl -o export" or via systemd-journal-gatewayd. This is much simpler to parse, but complete and accurate. Due to its stream-based nature it is not indexed.

Or, to put this in other words: '''This document is probably not what you want for your project'''. You want our [[http://www.freedesktop.org/software/systemd/man/sd-journal.html|C API]] instead! And if you really don't want the C API, then you want the [[http://www.freedesktop.org/wiki/Software/systemd/export|Journal Export Format]] instead! This document OTOH is primarily for your entertainment and education. Thank you!

We assume that you have a basic understand of the journal concepts, the properties of a journal entry and so on. If not, please go and read up, then come back!

This document describes the current format of systemd 195. The format is compatible with the format used in the first commits of the journal, but received various compatible additions since.

== Basics ==

 * All offsets, sizes, time values, hashes (and most other numeric values) are 64bit unsigned integers in LE format.
 * Offsets are always relative to the beginning of the file.
 * The 64bit hash function used is [[https://en.wikipedia.org/wiki/Jenkins_hash_function|Jenkins lookup3]], more specifically jenkins_hashlittle2() with the first 32bit integer it returns as higher 32bit part of the 64bit value, and the second one uses as lower 32bit part.
 * All structures are aligned to 64bit boundaries and padded to multiples of 64bit
 * The format is designed to be read via memory maps using multiple mapped windows.
 * All time values are stored in usec since the respective epoch.
 * Wall clock time values are relative to the Unix time epoch, i.e. January 1st, 1970. (CLOCK_REALTIME)
 * Monotonic time values are always stored jointly with kernel boot ID value (i.e. /proc/sys/kernel/random/boot_id) they belong to. They are relative to the begin of the boot. (CLOCK_MONOTONIC)

== General Rules ==

If any kind of corruption is noticed by a writer it should immediately rotate the file and start a new one. No further writes should be attempted to the original file, but it should be left around so that as little data as possible is lost.

If any kind of corruption is noticed by a reader it should try hard to handle this gracefully, such as skipping over the corrupted data, but allowing access to as much data around it as possible.

A reader should verify all offsets and other data as it reads it. This includes checking for alignment and range of offsets in the file, especially before trying to read it via a memory map.

== Structure ==

The file format's data structures are declared in [[http://cgit.freedesktop.org/systemd/systemd/tree/src/journal/journal-def.h|journal-def.h]].

The file format begins with a header structure. After the header structure object structures follow. Objects are appended to the end as time progresses. Most data stored in these objects is not altered anymore after having been written once, with the exception of records necessary for indexing. When new data is appended to a file the writer first writes all new objects to the end of the file, and then links them up at front after that's done. Currently, seven different object types are known:

{{{
enum {
        OBJECT_UNUSED,
        OBJECT_DATA,               
        OBJECT_FIELD,
        OBJECT_ENTRY,
        OBJECT_DATA_HASH_TABLE,
        OBJECT_FIELD_HASH_TABLE,
        OBJECT_ENTRY_ARRAY,        
        OBJECT_TAG,
        _OBJECT_TYPE_MAX
};
}}}

 * A '''DATA''' object, which encapsulates the contents of one field of an entry, i.e. a string such as "_SYSTEMD_UNIT=avahi-daemon.service", or "MESSAGE=Foobar made a booboo." but possibly including large or binary data, and always prefixed by the field name and "=".
 * A '''FIELD''' object, which encapsulates a field name, i.e. a string such as "_SYSTEMD_UNIT" or "MESSAGE", without any "=" or even value.
 * An '''ENTRY''' object, which binds several '''DATA''' objects together into a log entry.
 * A '''DATA_HASH_TABLE''' object, which encapsulates a hash table for finding existing '''DATA''' objects.
 * A '''FIELD_HASH_TABLE''' object, which encapsulates a hash table for finding existing '''FIELD''' objects.
 * An '''ENTRY_ARRAY''' object, which encapsulates a sorted array of offsets to entries, used for seeking by bisection.
 * A '''TAG''' object, consisting of an FSS sealing tag for all data from the beginning of the file or the last tag written (whichever is later).

The Header struct defines, well, you guessed it, the file header:

{{{
_packed_ struct Header {
        uint8_t signature[8]; /* "LPKSHHRH" */
        le32_t compatible_flags;
        le32_t incompatible_flags;
        uint8_t state;
        uint8_t reserved[7];
        sd_id128_t file_id;
        sd_id128_t machine_id;
        sd_id128_t boot_id;    /* last writer */
        sd_id128_t seqnum_id;
        le64_t header_size;
        le64_t arena_size;
        le64_t data_hash_table_offset;   
        le64_t data_hash_table_size;
        le64_t field_hash_table_offset;  
        le64_t field_hash_table_size;
        le64_t tail_object_offset;
        le64_t n_objects;
        le64_t n_entries;
        le64_t tail_entry_seqnum;
        le64_t head_entry_seqnum;
        le64_t entry_array_offset;
        le64_t head_entry_realtime;
        le64_t tail_entry_realtime;
        le64_t tail_entry_monotonic;
        /* Added in 187 */
        le64_t n_data;
        le64_t n_fields;
        /* Added in 189 */
        le64_t n_tags;
        le64_t n_entry_arrays;
};
}}}

The first 8 bytes of Journal files must contain the ASCII characters LPKSHHRH.

If a writer finds that the '''machine_id''' of a file to write to does not match the machine it is running on it should immediately rotate the file and start a new one.

When journal file is first created the '''file_id''' is randomly and uniquely initialized.

When a writer opens a file it shall initialize the '''boot_id''' to the current boot id of the system.

The currently used part of the file is the '''header_size''' plus the '''arena_size''' field of the header. If a writer needs to write to a file where the actual file size on disk is smaller than the reported value it shall immediately rotate the file and start a new one. If a write is asked to write to a file with a header that is shorter than his own definition of the struct Header, he shall immediately rotate the file and start a new one.

The '''n_objects''' field contains the a counter for objects currently available in this file. As objects are appended to the end of the file this counters is increased.

The first object in the file starts immediately after the header. The last object in the file is at the offset '''tail_object_offset''', which may be 0 if no object is in the file yet.

The '''n_entries''', '''n_data''', '''n_fields''', '''n_tags''', '''n_entry_arrays''' are counters of the objects of the specific types.

'''tail_entry_seqnum''' and '''head_entry_seqnum''' contain the sequential number (see below) of the last or first entry in the file, respectively, or 0 if no entry has been written yet.

'''tail_entry_realtime''' and '''head_entry_realtime''' contain the wallclock timestamp of the last or first entry in the file, respectively, or 0 if no entry has been written yet.

'''tail_entry_monotonic''' is the monotonic timestamp of the last entry in the file, referring to monotonic time of the boot identified by '''boot_id'''.

== Extensibility ==

The format is supposed to be extensible in order to enable future additions of features. Readers should simply skip objects of unknown types as they read them. If a compatible feature extension is made a new bit is registered in the header's 'compatible_flags' field. If an  feature extension is used that makes the format incompatible a new bit is registered in the header's 'incompatible_flags' field. Readers should check these two bit fields, if they find a flag they don't understand in compatible_flags they should continue to read the file, but if they find one in 'incompatible_flags' they should fail, asking for an update of the software. Writers should refuse writing if there's an unknown bit flag in either of these fields.

The file header may be extended as new features are added. The size of the file header is stored in the header. All hader fields up to "n_data" are known to unconditionally exist in all revisions of the file format, all fields starting with "n_data" needs to be explicitly checked for via a size check, since they were additions after the initial release.

Currently only two extensions flagged in the flags fields are known:

{{{
enum {
        HEADER_INCOMPATIBLE_COMPRESSED = 1
};

enum {
        HEADER_COMPATIBLE_SEALED = 1
};
}}}

HEADER_INCOMPATIBLE_COMPRESSED indicates that the file includes DATA objects that are compressed using XZ.

HEADER_COMPATIBLE_SEALED indicates that the file includes TAG objects required for Forward Secure Sealing.

==  Dirty Detection ==

{{{
enum {
        STATE_OFFLINE = 0,
        STATE_ONLINE = 1,
        STATE_ARCHIVED = 2,
        _STATE_MAX
};
}}}

If a file is opened for writing the '''state''' field should be set to STATE_ONLINE. If a file is closed after writing the '''state''' field should be set to STATE_OFFLINE. After a file has been rotated it should be set to STATE_ARCHIVED. If a writer is asked to write to a file that is not in STATE_OFFLINE it should immediately rotate the file and start a new one, without changing the file.

After and before the state field is changed fdatasync() should be executed on the file to ensure the dirty state hits disk.

== Sequence Numbers ==

All entries carry sequence numbers that are monotonically counted up for each entry (starting at 1) and are unique among all files which carry the same '''seqnum_id''' field. This field is randomly generated when the journal daemon creates its first file. All files generated by the same journal daemon instance should hence carry the same seqnum_id. This should guarantee a monotonic stream of sequential numbers for easy interleaving even if entries are distributed among several files, such as the system journal and many per-user journals.

== Concurrency ==

The file format is designed to be usable in a single-writer/multiple-reader scenario. The synchronization model is very weak in order to facilitate storage on the most basic of file systems, and allow good performance. No file locking is used. The only time where disk synchronization via fdatasync() should be enforced is after and before changing the '''state''' field. It is recommended to execute a memory barrier after appending and initializing new fields at the end of the file, and before linking it up in the older objects.

It is crucial that readers verify the structural they read and handle invalid structure gracefully. (This is crucial anyway out of security considerations.) This specifically includes checking offset values, and that they point to valid objects, with valid sizes and of the type expected. All code must be written with the fact in mind that a file with inconsistent structure file might just be inconsistent temporarily, and might become consistent later on. Payload OTOH requires less scrutiny, as it should only be linked up, and hence visible to readers after it was successfully written to memory (tough not necessarily to disk).
