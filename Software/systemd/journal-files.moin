[[http://www.freedesktop.org/wiki/Software/systemd/|Back to systemd]]

= Journal File Format =

The systemd journal stores log data in a binary format with several features:

 * Fully indexed by all fields
 * Can store binary data, up to 2^64-1 in size
 * Seekable
 * Primarily append-based, hence robust to corruption
 * Support for in-line compression
 * Support for in-line Forward Secure Sealing

This document explains the basic structure of the file format on disk. We are making this available primarily to allow review and provide documentation. Note that the actual implementation in the [[http://cgit.freedesktop.org/systemd/systemd/tree/src/journal|systemd codebase]] is the only ultimately authoritative description of the format, so if this documentation and the code disagree, the code is right. That said we'll of course try hard to keep this documentation up-to-date and accurate.

Instead of implementing your own reader or writer for journal files we ask you to use the [[http://www.freedesktop.org/software/systemd/man/sd-journal.html|Journal's native C API]] to access these files. It provides you with full access to the files, without limitations, and will not withhold any data. If you find a limitation, please ping us and we might add some additional interfaces for you.

If you need access to the raw journal data in serialized stream form without C API our recommendation is to make use of the [[http://www.freedesktop.org/wiki/Software/systemd/export|Journal Export Format]], which you can get via "journalctl -o export" or via systemd-journal-gatewayd. This is much simpler to parse, but complete and accurate. Due to its stream-based nature it is not indexed.

Or, to put this in other words: '''This document is probably not what you want for your project'''. You want our [[http://www.freedesktop.org/software/systemd/man/sd-journal.html|C API]] instead! And if you really don't want the C API, then you want the [[http://www.freedesktop.org/wiki/Software/systemd/export|Journal Export Format]] instead! This document OTOH is primarily for your entertainment and education. Thank you!

We assume that you have a basic understand of the journal concepts, the properties of a journal entry and so on. If not, please go and read up, then come back!

This document describes the current format of systemd 195. The format is compatible with the format used in the first commits of the journal, but received various compatible additions since.

== Basics ==

 * All offsets, sizes, hashes (and most other numeric values) are 64bit unsigned integers in LE format.
 * Offsets are always relative to the beginning of the file.
 * The 64bit hash function used is [[https://en.wikipedia.org/wiki/Jenkins_hash_function|Jenkins lookup3]], more specifically jenkins_hashlittle2() with the first 32bit integer it returns as higher 32bit part of the 64bit value, and the second one uses as lower 32bit part.
 * All structures are aligned to 64bit boundaries and padded to multiples of 64bit
 * The format is designed to be read via memory maps using multiple mapped windows.

The file format's data structures are declared in [[http://cgit.freedesktop.org/systemd/systemd/tree/src/journal/journal-def.h|journal-def.h]].

The file format begins with a header structure. After the header structure object structures follow. Objects are appended to the end. Most data stored in these objects is not altered anymore after having been written once, with the exception of records necessary for indexing. When new data is appended to a file the writer first writes all new objects to the end of the file, and then links them up at front after that's done. Currently, seven different object types are known:

 * A '''DATA''' object, which encapsulates the contents of one field of an entry, i.e. a string such as "_SYSTEMD_UNIT=avahi-daemon.service", or "MESSAGE=Foobar made a booboo." but possibly including large or binary data, and always prefixed by the field name and "=".
 * A '''FIELD''' object, which encapsulates a field name, i.e. a string such as "_SYSTEMD_UNIT" or "MESSAGE", without any "=" or even value.
 * An '''ENTRY''' object, which binds several '''DATA''' objects together into a log entry.
 * A '''DATA_HASH_TABLE''' object, which encapsulates a hash table for finding existing '''DATA''' objects.
 * A '''FIELD_HASH_TABLE''' object, which encapsulates a hash table for finding existing '''FIELD''' objects.
 * An '''ENTRY_ARRAY''' object, which encapsulates a sorted array of offsets to entries, used for seeking by bisection.
 * A '''TAG''' object, consisting of an FSS sealing tag for all data from the beginning of the file or the last tag written (whichever is later).

== Extensibility ==

The format is supposed to be extensible in order to enable future additions of features. Readers should simply skip objects of unknown types as they read them. If a compatible feature extension is made a new bit is registered in the header's 'compatible_flags' field. If an  feature extension is used that makes the format incompatible a new bit is registered in the header's 'incompatible_flags' field. Readers should check these two bit fields, if they find a flag they don't understand in compatible_flags they should continue to read the file, but if they find one in 'incompatible_flags' they should fail, asking for an update of the software. Writers should refuse writing if there's an unknown bit flag in either of these fields.

The file header may be extended as new features are added. The size of the file header is stored in the header. All hader fields up to "n_data" are known to unconditionally exist in all revisions of the file format, all fields starting with "n_data" needs to be explicitly checked for via a size check, since they were additions after the initial release.

The first 8 bytes of Journal files must contain the letters LPKSHHRH.
