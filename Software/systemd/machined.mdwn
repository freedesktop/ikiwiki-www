[[Back to systemd|http://www.freedesktop.org/wiki/Software/systemd/]]

# machined

systemd 205 and newer include systemd-machined. This is a tiny daemon that tracks locallly running Virtual Machines and Containers in various ways.

See [[systemd-machined(8).service|http://www.freedesktop.org/software/systemd/man/systemd-machined.service.html]] for more information.

The daemon provides both a C library interface (which is shared with [[logind|http://www.freedesktop.org/wiki/Software/systemd/logind]]) as well as a D-Bus interface. The library interface may be used to introspect, register and watch the state of virtual machines/containers. The bus interface provides the same but in addition may also be used to make changes to system state. For more information please consult the man pages: [[sd-login(7)|http://www.freedesktop.org/software/systemd/man/sd-login.html]]

machined is useful for registering and keeping track of both OS containers (i.e. containers that share the host kernel but run a full init system of their own and behave in most regards like a full virtual operating system rather than just one virtualized app or similar) and full virtual machines (i.e. virtualized hardware running normal operating systems and possibly different kernels). It should **not** be used for registering/keeping track application containers. A *machine* in the context of machined is supposed to be an abstract term covering both OS containers and full virtual machines.

If you are interested in writing a VM or container manager that makes use of machined, please have look at [[Writing Virtual Machine or Container Managers|http://www.freedesktop.org/wiki/Software/systemd/writing-vm-managers]].

## The Manager Object

The service exposes the following interfaces on the Manager object on the bus:

    node /org/freedesktop/machine1 {
      interface org.freedesktop.machine1.Manager {
        methods:
          GetMachine(in  s name,
                     out o machine);
          GetMachineByPID(in  u pid,
                          out o machine);
          ListMachines(out a(ssso) machines);
          CreateMachine(in  s name,
                        in  ay id,
                        in  s service,
                        in  s class,
                        in  u leader,
                        in  s root_directory,
                        in  a(sv) scope_properties,
                        out o path);
          KillMachine(in  s name,
                      in  s who,
                      in  s signal);
          TerminateMachine(in  s id);
        signals:
          MachineNew(s machine,
                     o path);
          MachineRemoved(s machine,
                         o path);
        properties:
      };
      interface org.freedesktop.DBus.Properties {
      };
      interface org.freedesktop.DBus.Peer {
      };
      interface org.freedesktop.DBus.Introspectable {
      };
    };

### Methods

**GetMachine()** may be used to get the machine object path for the machine with the specified name. Similar, **GetMachineByPID()** get the machine object the specified PID belongs to if there is any.

**ListMachines()** returns an array with all currently registered machines. The structures in the array consist of the following fields: machine name, machine class, an identifier for the service that registered the machine and the machine object path.

**CreateMachine()** may be used to register new virtual machines or container with machined. As argument this takes a machine name chosen by the registrar, an optional UUID as 32 byte array, a string that identifies the service that registers the machine, a class string, the PID of the leader process of the machine, an optional root directory of the container, and an array of additional properties to pass to the scope registration. The virtual machine name must be suitable as a file name, and hence not contain any slashes, or be the empty string, or single/double full stops. Only 7 Bit ASCII is permitted. The UUID is passed as 32 byte array, or if no suitable UUID is available an empty array shall be passed. The UUID should identify the virtual machine/container uniquely, and should ideally be the same one as /etc/machine-id in the VM/container, if that's possible. The service string can be free-form, but it is recommended to parse a short lowercase identifier like "systemd-nspawn", "libvirt-lxc" or suchlike. The leader PID should be the host PID of the init process of the container, or the encapsulating process of the VM. If the root directory of the container is known and available in the host's hierarchy, it should be passed, otherwise use the empty string. Finally, the scope properties are passed as array in the same way as PID1's StartTransientUnit() accepts it. This method call will internally register a transient scope unit for the calling client (utilizing the passed scope_properties), and move the leader PID into it. The call returns an object path for the registered machine object.
