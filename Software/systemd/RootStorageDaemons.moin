= systemd and Storage Daemons for the Root File System =

aka. Pax Cellae pro Radix

(or something like that, my Latin is a bit rusty)

A number of modern storage technologies on Linux (e.g. RAID, volume management, networked storage) require user space services to run while the storage is active and mountable. This requirement becomes tricky as soon as the root file system of the Linux operating system is stored on such storage technology. Previously no clear path to make this work was available. This text tries to clear up the resulting confusion, and what is now supported and what is not.

== A Bit of Background ==

When complex storage technologies are used as backing for the root file system this needs to be set up by the initial RAM disk (initrd), i.e. on Fedora by Dracut. In newer systemd versions teardown of the root file system backing is also done by the initrd: after terminating all remaining running processes and unmounting all file systems it can (which means excluding the root fs) systemd will jump back into the initrd code allowing it to unmount the final file system (and its storage backing) that could not be unmounted as long as the OS was still running from the main root file system. The initrd's job is to detach/unmount the root fs, i.e. inverting the exact commands it used to set them up in the first place. This is not only cleaner, but also allows for the first time arbitrary complex stacks of storage technology.

Previous attempts to handle root file system setups with complex storage as backing usually tried to maintain the root storage with program code stored on the root storage itself, thus creating a number of dependency loops. Safely detaching such a root file system becomes messy, since the program code on the storage needs to stay around longer than the storage, which is a technically contradicting.

== What's new ==

As a result, we hereby clarify that we do not support storage technology setups where the storage daemons are being run from the storage it maintains itself. In other words: a storage daemon backing the root file system cannot be stored on the root file system itself. 

What we do support instead is that these storage daemons are started from the initrd, stay running all the time during normal operation and are terminated only after we returned control back to the initrd and by the initrd. As such, storage daemons involved with maintaining the root file system storage conceptually are more like kernel threads than like normal system services: from the perspective of the init system (i.e. systemd) these services have been started before systemd got initialized and stay around until after systemd is already gone. These daemons can only be updated by updating the initrd and rebooting, a takeover from initrd-supplied services to replacements from the root file system is supported.

== What does this mean ==

On system shutdown, systemd will execute a small tool called systemd-shutdown. This tool (which runs as PID 1, it entirely replace the systemd init process) then iterates through the mounted file systems and running processes (as well as a couple of other resources) and tries to unmount/read-only mount/detach/kill them. It continues to do this in a tight loop as long as this results in any effect. From this killing spree a couple of processes are automatically excluded: PID 1 itself of course, as well as all kernel threads. After the killing/unmounting spree control is passed back to the initrd.

To implement the supported logic proposed above, where storage daemons needed for the root fs which are started by the initrd stay around during normal operation and are only killed when control is passed back to the initrd we need to exclude these daemons from the shutdown killing spree. To accomplish this the following logic is available starting with systemd 38:

Processes whose first character of the zeroth command line argument is '@' are excluded from the killing spree, much the same way as kernel threads are excluded too. Thus, a daemon which wants to take advantage of this logic needs to place the following at the top of its main() function:

{{{
int main(int argc, char *argv) {
        argv[0][0] = '@';
        ...
}
}}}

And that's already it. Note thtat this functionality is only to be used by programs running from the initrd, and *not* for programs running from the root file system itself. Programs which use this functionality and are running from the root file system are considered buggy since they effectively prohibit clean unmounting/detaching of the root file system and its backing storage.

Again: if your code is being run from the root file system, then this logic suggested above is NOT for you. Sorry. Talk to us, we can probably help you to find a different solution to your problem.

The recommended way to distuingish between run-from-initrd and run-from-rootfs for a daemon is to introduce a new switch --initrd for your service which when passed results in argv[0][0] being set to '@', and otherwise doesn't. An updated initrd (i.e. Dracut) should then simply pass that switch and everything's jolly.

Why '@'? Why argv[0][0]? First of all, a technique like this is noth without precedent: traditionally Unix login shells set argv[0][0] to '-' to clarify they are login shells. This logic is also very easy to implement. We have been looking for other ways to mark processes for exclusion from the killing spree, but could not find any that was equally simple to implement and quick to read when traversing through /proc. Also, as a side effect replacing the first character of argv[0] with '@' also visually invalidates the path normally stored in argv[0] (which usually starts with '/') thus helping the administrator to understand that your daemon is actually not originating from the actual root file system, but from a path in a completely different namespace (i.e. the initrd namespace). 
