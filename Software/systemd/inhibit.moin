[[http://www.freedesktop.org/wiki/Software/systemd/|Back to systemd]]

= Inhibition Logic =

systemd 183 and newer include a logic to inhibit system shutdowns and sleep states. This is implemented as part of [[http://www.freedesktop.org/software/systemd/man/systemd-logind.service.html|systemd-logind.daemon(8)]] There are a couple of different usecases for this:

 * A CD burning application wants to ensure that the system is not turned off or suspended while the burn process is in progress.
 * A package manager wants to ensure that the system is not turned off while a package upgrade is in progress.
 * An office suite wants to be notified before system suspend in order to save all data to disk, and delay the suspend logic until all data is written.
 * A web browser wants to be notified before system hibernation in order to free its cache to minimize the amount of memory that needs to be virtualized.

Applications which want to make use of the inhibition logic shall take an inhibitor lock via the [[http://www.freedesktop.org/wiki/Software/systemd/logind|logind D-Bus API]].

Three distinct inhibitor lock types may be taken, or a combination of them:

 1. ''sleep'' inhibits '''user-requested''' system suspend and hibernation
 2. ''shutdown'' inhibits '''user-requested''' system power-off and reboot
 3. ''idle'' inhibits that the system goes into idle mode, possibly resultin in '''automatic''' system suspend or shutdown depending on configuration.

Two different modes of locks are supported:

 1. ''block'' inhibits operations entirely until the lock is released. If such a lock is taken the operation will fail (but still may be overriden if the user possesses the necessary privileges).
 2. ''delay'' inhibits operations only temporarily, either until the lock is released or up to a certain amount of time. The !InhibitDelayMaxSec= setting in [[http://www.freedesktop.org/software/systemd/man/logind.conf.html|logind.conf(5)]] controls the timeout for this. This is intended to be used by applications which need a synchronous way to execute actions before system suspend but shall not be allowed to block suspend indefinitely.

Inhibitor locks are taken via the Inhibit() D-Bus call on the logind Manager object:

{{{
$ gdbus introspect --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1
node /org/freedesktop/login1 {
  interface org.freedesktop.login1.Manager {
    methods:
      Inhibit(in  s what,
              in  s who,
              in  s why,
              in  s mode,
              out h fd);
      ListInhibitors(out a(ssssuu) inhibitors);
      ...
    signals:
      PrepareForShutdown(b active);
      PrepareForSleep(b active);
      ...
    properties:
      readonly s BlockInhibited = '';
      readonly s DelayInhibited = '';
      readonly t InhibitDelayMaxUSec = 5000000;
      ...
  };
  ...
};
}}}

'''Inhibit()''' is the only API necessary to take a lock. It takes four arguments:

 * ''What'' is a colon-separated list of lock types, i.e. {{{shutdown}}}, {{{sleep}}}, {{{idle}}}. Example: "shutdown:idle"
 * ''Who'' is a human-readable, descriptive string of who is taking the lock. Example: "!Package Updater"
 * ''Why'' is a human-readable, descriptive string of why the lock is taken. Example: "Package Update in Progress"
 * ''Mode'' is one of {{{block}}} or {{{delay}}}, see above. Example: "block"

'''Inhibit()''' returns a single value, a file descriptor that encapsulates the lock. As soon as the file descriptor is closed (and all its duplicates) the lock is automatically released. If the client dies while the lock is taken the kernel automatically closes the file descriptors so that the lock is automatically released.

'''!ListInhibitors()''' lists all currently active inhibitor locks. It returns an array of structs, each consisting of What, Who, Why, Mode as above, plus the PID and UID of the process that requested the lock.

The '''!PrepareForShutdown()''' and '''!PrepareForSleep()''' signals are emitted if a system suspend or shutdown has been requested but a delay inhibitor lock has been taken and when all locks are released or the timeout reached. The signals carry a boolean argument. If true the shutdown/sleep preperation should begin, if false it ends.  If true, this should be used as indication to quickly execute the operations the applications wanted to execute before suspend and then release the delay lock. If false the preparation time for shutdown/sleep is over, either because all delay locks have have been released or because the timeout is reached. The signals with 'false' might get delivered only after the system comes back from system suspend. It is usually the signal on which applications request a new delay lock in order to be synchronously notified about the next suspend/shutdown. Note that !PrepareForShutdown()/PrepareForSleep() are ''not'' send out if no delay lock is taken, and more specifically not send out if only block locks are taken.

The '''!BlockInhibited''' and '''!DelayInhibited''' properties encode what types of locks are currently taken. These fields are a colon separated list of {{{shutdown}}}, {{{sleep}}}, {{{idle}}}. The list is basically the union of the What fields of all currently active locks of the specific mode.

'''InhibitDelayMaxUSec''' contains the delay timeout values as configured in [[http://www.freedesktop.org/software/systemd/man/logind.conf.html|logind.conf(5)]].

Here's the basic scheme for applications which need blocking locks such as a package manager or CD burning application:

 1. Take the lock
 2. Do your work you don't want to see interrupted by system sleep or shutdown
 3. Release the lock

Example pseudo code:
{{{
fd = Inhibit("shutdown:idle", "Package Manager", "Upgrade in progress...", "block");
/* ...
      do you work
                 ... */
close(fd);
}}}

Here's the basic scheme for applications which need delay locks such as a web browser or office suite:

 1. As your documents become dirty/cache is filled, take the delay lock
 2. As soon as you see !PrepareForSleep(true), save your data, then release the lock
 3. As soon as you see !PrepareForSleep(false) and your documents are dirty/cache is filled, take the delay lock again, continue as above:

Example pseudo code:
{{{
int fd = -1;

onDocumentIsDirty(void) {
        if (fd >= 0)
                return;

        fd = Inhibit("sleep", "Word Processor", "Data needs to be saved...", "delay");
}

onPrepareForSleep(bool b) {
        if (b) {
                save_data();
                if (fd >= 0) {
                        close(fd);
                        fd = -1;
                }
         }
}       
}}}

Taking inhibitor locks is a privileged operation. To take a ''delay'' lock the !PolicyKit privilege ''org.freedesktop.login1.inhibit-delay'' is required, for a ''block'' lock ''org.freedesktop.login1.inhibit-block'' is needed. In general it should be assumed that delay locks are easier to obtain thatn blocking locks, simply because their impact is much more minimal. Note that the policy checks for Inhibit() are never interactive.

Inhibitor locks should not be misused. For example taking sleep blocking locks without a very good reason might cause laptops to never suspend if the lid is closed. This can be dangerous for the hardware.

If an application finds a lock denied it should not consider this much of an error and just continue its operation without the protecting lock.

The tool [[http://www.freedesktop.org/software/systemd/man/systemd-inhibit.html|systemd-inhibit(1)]] may be used to take locks or list active locks from the command line.

Note that gnome-session also provides an [[http://people.gnome.org/~mccann/gnome-session/docs/gnome-session.html#org.gnome.SessionManager.Inhibit|inhibitor API]], which is very similar to the one of systemd. Internally, locks taken on gnome-session's interface will be forwarded to logind, hence both APIs are supported. While both offer similar functionality they do differ in some regards. For obvious reasons gnome-session can offer logout locks and screensave avoidance locks which logind lacks. logind's API OTOH supports delay locks in addition to block locks like GNOME. Also, logind is available to system components, and centralizes locks from all users, not just the one of a one specific one. In general: if in doubt it is probably advisable to stick to the GNOME locks, unless there is a good reason to use the logind APIs directly. When locks are to be enumerated it is better to use the logind APIs however, since they also include locks taken by system services and other users.
