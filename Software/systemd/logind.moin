= logind =

systemd 30 and newer include systemd-logind. This is a tiny daemon that can manages user logins and seats in various ways.

See http://www.freedesktop.org/software/systemd/man/systemd-logind.service.html for more information. Please consult http://www.freedesktop.org/wiki/Software/systemd/multiseat for more information on the basic concepts.

The daemon provides both a C library interface as well as a D-Bus interface. The library interface may be used to introspect and watch the state of user logins or seat. The bus interface provides the same but in addition may also be used to make changes to system state. For more more information please consult the man pages: http://www.freedesktop.org/software/systemd/man/sd-login.html

== The Manager Object ==

The service exposes the following interfaces on the Manager object on the bus:

{{{
$ gdbus introspect --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1
node /org/freedesktop/login1 {
  interface org.freedesktop.login1.Manager {
    methods:
      GetSession(in  s id,
                 out o session);
      GetSessionByPID(in  u pid,
                      out o session);
      GetUser(in  u uid,
              out o user);
      GetSeat(in  s id,
              out o seat);
      ListSessions(out a(susso) sessions);
      ListUsers(out a(uso) users);
      ListSeats(out a(so) seats);
      CreateSession(...);
      ReleaseSession(...);
      ActivateSession(in  s id);
      ActivateSessionOnSeat(in  s id,
                            in  s seat);
      LockSession(in  s id);
      UnlockSession(in  s id);
      KillSession(in  s id,
                  in  s who,
                  in  s signal);
      KillUser(in  u uid,
               in  s signal);
      TerminateSession(in  s id);
      TerminateUser(in  u uid);
      TerminateSeat(in  s id);
      SetUserLinger(in  u uid,
                    in  b b,
                    in  b interactive);
      AttachDevice(in  s seat,
                   in  s sysfs,
                   in  b interactive);
      FlushDevices(in  b interactive);
      PowerOff(in  b interactive);
      Reboot(in  b interactive);
      Suspend(in  b interactive);
      Hibernate(in  b interactive);
      CanPowerOff(out s result);
      CanReboot(out s result);
      CanSuspend(out s result);
      CanHibernate(out s result);
      Inhibit(in  s what,
              in  s who,
              in  s why,
              in  s mode,
              out h fd);
      ListInhibitors(out a(ssssuu) inhibitors);
    signals:
      SessionNew(s id,
                 o path);
      SessionRemoved(s id,
                     o path);
      UserNew(u uid,
              o path);
      UserRemoved(u uid,
                  o path);
      SeatNew(s id,
              o path);
      SeatRemoved(s id,
                  o path);
      PrepareForShutdown(b active);
      PrepareForSleep(b active);
    properties:
      readonly s ControlGroupHierarchy = '/user';
      readonly as Controllers = [];
      readonly as ResetControllers = ['cpu'];
      readonly u NAutoVTs = 6;
      readonly as KillOnlyUsers = [];
      readonly as KillExcludeUsers = ['root'];
      readonly b KillUserProcesses = false;
      readonly b IdleHint = false;
      readonly t IdleSinceHint = 1340873864854884;
      readonly t IdleSinceHintMonotonic = 14409495315;
      readonly s BlockInhibited = '';
      readonly s DelayInhibited = '';
      readonly t InhibitDelayMaxUSec = 5000000;
      readonly s HandlePowerKey = 'no-session';
      readonly s HandleSleepKey = 'tty-session';
      readonly s HandleLidSwitch = 'off';
  };
  interface org.freedesktop.DBus.Properties {
  };
  interface org.freedesktop.DBus.Peer {
  };
  interface org.freedesktop.DBus.Introspectable {
  };
};
}}}

Whenever the inhibition state or idle hint changes daemon !PropertyChanged signals are sent out to which clients can subscribe. 

A number of operations are protected via the !PolicyKit privilege system. !SetUserLinger() requires the org.freedesktop.login1.set-user-linger privilege. !AttachDevice() requires org.freedesktop.login1.attach-device and !FlushDevices org.freedesktop.login1.flush-devices. !PowerOff(), !Reboot(), !Hibernate(), !Suspend() require org.freedesktop.login1.power-off, org.freedesktop.login1.power-off-multiple-sessions, org.freedesktop.login1.power-off-ignore-inhibit, org.freedesktop.login1.reboot, org.freedesktop.login1.reboot-multiple-sessions, org.freedesktop.login1.reboot-ignore-inhibit, org.freedesktop.login1.suspend, org.freedesktop.login1.suspend-multiple-sessions, org.freedesktop.login1.suspend-ignore-inhibit, org.freedesktop.login1.hibernate, org.freedesktop.login1.hibernate-multiple-sessions resp. org.freedesktop.login1.hibernate-ignore-inhibit, depending whether there are other sessions around or active inhibits.

The user_interaction boolean parameters can be used to control wether !PolicyKit should interactively ask the user for authentication credentials if it needs to. 

!GetSession() may be used to get the session object path for the session with the specified ID. Similar, !GetUser() and !GetSeat() get the user resp. seat objects. !GetSessionByPID() gets the session object of the session the specified PID belongs to if there is any.

!ListSessions() returns an array with all current sessions. The structures in the array consist of the following fields: session id, user id, user name, seat id, session object path. If a session does not have a seat attached the seat id field will be the empty string.

!ListUsers() returns an array with all currently logged in users. The structures in the array consists of the following fields: user id, user name, user object path.

!ListSeats() returns an arry with all currently available seats. The structure in the array consists of the following fields: seat id, seat object path.

!CreateSession() and !ReleaseSession() may be used to open or close login sessions. These calls should ''never'' be invoked directly by clients. Creating/closing sessions is exclusively the job PAM and it's pam_systemd module. 

!ActivateSession() brings the session with the specified ID into the foreground. !ActivateSessionOnSeat() does the same, but only if the seat id matches.

!LockSession() asks the session with the specified ID to activate the screen lock.

!UnlockSession() asks the session with the specified ID to remove the screen lock.

!KillSession() may be used to send a Unix signal to one or all processes of a session. As arguments it takes the session id, either the string "leader" or "all" and a signal number. If "leader" is passed only the session "leader" is killed. If "all" is passed all processes of the session are killed.

!KillUser() may be used to send a Unix signal to all processes of a user. As arugment it takes the user id and a signal number.

!TerminateSession(), !TerminateUser(), !TerminateSeat may be used to forcibly terminate one specific session, all processes of a user, resp. all sessions attached to a specific seat. The session, user, seat is identified by their respective IDs.

!SetUserLinger() enables or disables user lingering. If enabled the runtime directory of a user is kept around and he may continue to run processes while he is logged out. If disabled the runtime directory goes away as soon as he logs out. Expects three arguments: the UID, a boolean whether to enable/disable and a boolean controlling the !PolicyKit authorization interactivity (see above). Note that the user linger state is persistantly stored on disk.

!AttachDevice() may be used to assign a specific a device to a specific seat. The device is identified by its /sys path, and must be eligible for seat assignments. Takes three arguments: the seat id, the sysfs path, and a boolean for controlling !PolicyKit interactivity (see above). Device assignments are persistantly stored to disk. To create a new seat, simply specify a previously unused seat id. For more information about the seat assignment logic see: http://www.freedesktop.org/wiki/Software/systemd/multiseat

!FlushDevices() removes all explicit seat assignments for devices, resetting all assignments to the automatic defaults. The only argument this takes is the !PolicyKit interactivity boolean (see above).

!PowerOff(), Reboot(), Suspend(), Hibernate() results in the system being powered off, rebooted, suspend or hibernated. The only argument is the !PolicyKit interactivity boolean (see above). The main purpose of these calls is that they enforce PolicyKit policy and hence allow powering off/rebooting/suspending/hibernating even by unprivileged users. They also enforce inhibition locks. UIs should expose these calls as primary mechanism to poweroff/reboot/suspend/hibernate the machine.

!CanPowerOff(), !CanReboot(), !CanSuspend(), !CanHibernate() tests whether the system supports the respective operation and whether calling user is eligible for the desired operation. Returns one of "yes", "no" or "challenge". If "challenge" is returned the operation is available, but only after authorization.

Inhibit() creates an inhibition lock. It takes four parameters: What, Who, Why and Mode. "What" is one or more of "shutdown", "sleep" and "idle", separated by colons, for inhibiting poweroff/reboot, suspend/hibernate, or the automatic idle logic. "Who" should be short human readable string identifying the application taking the lock. "Why" should be a short human readable string identifying the reason why the lock is taken. Finally, "Mode" is either "block" or "delay" which encodes whether the inhibit shall be consider mandatory or whether it should just delay the operation to a certain maximum time. The call returns a file descriptor. The lock is released the moment this file descriptor (and all is duplicates) is closed. For more information on the inhibition logic see: http://www.freedesktop.org/wiki/Software/systemd/inhibit

!ListInhibitors() lists all currently active inhibitors. Returns an array of structures consisting of what, who, why, mode, user ID and process ID.

The !SessionNew(), !SessionRemoved(), !UserNew(), !UserRemoved(), !SeatNew(), !SeatRemoved() signals are sent each time a session is created or removed, a user logs in or out, or a seat added or removed. They each contain the ID of the object plus the object path.

The !PrepareForShutdown() resp. !PrepareForSleep() signals are sent immediately before the system goes down for reboot/poweroff, resp. suspend/hibernate, if at least one inhibition lock is taken. This may be used by applications for saving data on disk, releasing memory or doing other jobs that shall be done shortly before shutdown/sleep. After completation they should release their inhibition locks in order not to delay the operation any further.

Most properties simply reflect the configuration stored in logind.conf. For more information, see: http://www.freedesktop.org/software/systemd/man/logind.conf.html

The !IdleHint property reflects the idle hint state of the system. !IdleSinceHint and !IdleSinceHintMonotonic encode the timestamps of the last change of the idle int boolean, in CLOCK_REALTIME resp. CLOCK_MONOTONIC timestamps in usec since the epoch.

The !BlockInhibited and !DelayInhibited properties encode the currently active locks of the respective modes. They are colon separated lists of "shutdown", "sleep", "idle" (see above).

== Seat Objects ==

{{{
$ gdbus introspect --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1/seat/seat0
node /org/freedesktop/login1/seat/seat0 {
  interface org.freedesktop.login1.Seat {
    methods:
      Terminate();
      ActivateSession(in  s id);
    signals:
    properties:
      readonly s Id = 'seat0';
      readonly so ActiveSession = ('2', '/org/freedesktop/login1/session/2');
      readonly b CanMultiSession = true;
      readonly b CanTTY = true;
      readonly b CanGraphical = true;
      readonly a(so) Sessions = [('2', '/org/freedesktop/login1/session/2')];
      readonly b IdleHint = false;
      readonly t IdleSinceHint = 1340873864854884;
      readonly t IdleSinceHintMonotonic = 14409495315;
  };
  interface org.freedesktop.DBus.Properties {
  };
  interface org.freedesktop.DBus.Peer {
  };
  interface org.freedesktop.DBus.Introspectable {
  };
};
}}}

Terminate() and !ActivateSession() work similar to !TerminateSeat(), ActivationSessionOnSeat() on the Manager object.

The Id property encodes the Id of the seat.

!ActiveSession encodes the currently active session if there is one. It is a structure consisting of session id and object path.

!CanMultiSession encodes whether the session is multi-session capable, !CanTTY whether it is suitable for text logins, !CanGraphical whether it is suitable for graphical sessions. 

The Sessions array is an array of all current sessions of this seat, each encoded in a structure consisting of the ID and the object path. 

The IdleHint, IdleSinceHint, IdleSinceHint properties encode the idle state, similar to the one exposed on the Manager object, but specific for this seat.

== User Objects ==

This D-Bus interface follows [[http://0pointer.de/blog/projects/versioning-dbus.html|the usual interface versioning guidelines]].
