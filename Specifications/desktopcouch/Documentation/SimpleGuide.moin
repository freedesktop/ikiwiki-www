= Simple Guide to using desktopcouch in your applications =

This document describes in basic terms how to store data to and retrieve data from desktopcouch for application developers.

== desktopcouch.records ==

`desktopcouch.records` is the Python library for accessing desktopcouch from applications. Basic use is as follows (simple examples are also available offline in `/usr/share/doc/python-desktopcouch-records/api/records.txt`):

{{{
>>> from desktopcouch.records.server import CouchDatabase
>>> from desktopcouch.records.record import Record
}}}

Create a database object. Your database needs to exist. If it doesn't, you
can create it by passing create=True.

{{{
>>> db = CouchDatabase('testing', create=True)
}}}

Create a Record object. Records have a record type, which should be a
URL.  The URL should point to a human-readable document which
describes your record type. (This is not checked, though.) You can
pass in an initial set of data.

{{{
>>> r = Record({'a':'b'}, record_type='http://example.com/testrecord')
}}}

Records work like Python dicts.

{{{
>>> r['c'] = ['d','e','f']
}}}

Save the record into the database with put_record:

{{{
>>> record_id = db.put_record(r)
}}}

Fetch existing records from the database by ID:

{{{
>>> fetched = db.get_record(record_id)
>>> print fetched['a']
b
>>>
}}}

There is no ad-hoc query functionality.

For views, you should specify a design document for most all calls.

{{{
>>> design_doc = "application"
}}}

To create a view:

{{{
>>> map_js = """function(doc) { emit(doc._id, null) }"""
>>> reduce_js = None
>>> db.add_view("blueberries", map_js, reduce_js, design_doc)
}}}

List views for a given design document:

{{{
>>> db.list_views(design_doc)
['blueberries']
}}}

Test that a view exists:

{{{
>>> db.view_exists("blueberries", design_doc)
True
}}}

Execute a view.  Results from execute_view() take list-like syntax to
pick one or more rows to retrieve.  Use index or slice notation.

{{{
>>> result = db.execute_view("blueberries", design_doc)
>>> for row in result["idfoo"]:
...     pass  # all rows with id "idfoo".  Unlike lists, may be more than one.
}}}

Finally, remove a view.  It returns a dict containing the deleted view data.

{{{
>>> db.delete_view("blueberries", design_doc)
{'map': 'function(doc) { emit(doc._id, null) }'}
}}}

For most operations (except testing existence), if the view you ask for does
not exist, the function will throw a KeyError exception.

There are also some introductory desktopcouch code snippets on the [[https://wiki.ubuntu.com/Quickly/Snippets|Quickly code snippets]] page.

== couchdb-glib ==

`couchdb-glib` is a C library for accessing CouchDB servers, included desktopcouch. It heavily uses Glib's GObject to offer a nice API that easily integrates into GNOME/GTK applications.

To start using, first thing is to include the top-level header file
{{{
#include <couchdb-glib/couchdb-glib.h>
}}}

The entry point for the API is the ''CouchDB'' object, which can be obtained as shown in the following example:
{{{
CouchDB *couchdb;

couchdb = couchdb_new ("http://localhost:5984");
}}}
The only argument to ''couchdb_new'' is the URL of the CouchDB instance to connect to. If NULL, it would use the system-wide CouchDB instance (located at http://localhost:5984). Also, take into account that at the time of this writing, couchdb-glib doesn't know anything specific about desktopcouch, so you need to get the port and OAuth credentials as shown [[http://git.gnome.org./cgit/evolution-couchdb/tree/addressbook/e-book-backend-couchdb.c|here]] (see function ''e_book_backend_couchdb_load_source'' in that code). Code to do this automatically for you is being added to couchdb-glib unstable version, so should be available soon in the stable API.

Once you have a ''CouchDB'' object, you can do all the operations the API provides from it. Please note that most of the API functions have a ''GError'' argument as the last parameter, which is used to return error information to the caller.

First, you can list the databases that are available:
{{{
GSList *couchdb_list_databases (CouchDB *couchdb, GError **error);
}}}
This would return a list of ''CouchDBDatabaseInfo'' structures, which contain information (such as database name, number of documents, etc) for each database available on the CouchDB instance you're connecting to. If you already know the name of a database, you can easily obtain that information for that specific database with the following function:
{{{
CouchDBDatabaseInfo *couchdb_get_database_info (CouchDB *couchdb, const char *dbname, GError **error);
}}}

You can also create new databases:
{{{
gboolean couchdb_create_database (CouchDB *couchdb, const char *dbname, GError **error);
}}}

Or delete existing databases:
{{{
gboolean couchdb_delete_database (CouchDB *couchdb, const char *dbname, GError **error);
}}}

Also, before starting to work with documents on a specific database, you might want to listen for changes on the database(s) you're working with. To do so, you just need to call the following function:
{{{
void couchdb_listen_for_changes (CouchDB *couchdb, const char *dbname);
}}}
This will setup a listener for changes on the database specificied by the ''dbname'' argument. Notification of changes are sent to the caller via GObject's signals, so to actually receive those notifications in your application, you would need to connect to one (or all) of the following signals of the ''CouchDB'' object:
{{{
void (* database_created) (CouchDB *couchdb, const char *dbname);
void (* database_deleted) (CouchDB *couchdb, const char *dbname);
void (* document_created) (CouchDB *couchdb, const char *dbname, CouchDBDocument *document);
void (* document_updated) (CouchDB *couchdb, const char *dbname, CouchDBDocument *document);
void (* document_deleted) (CouchDB *couchdb, const char *dbname, const char *docid);
}}}
If you don't call ''couchdb_listen_for_changes'' on your program, you might still get some notifications through these signals of the changes done through your application, but you won't get any notification for external changes.
